<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Triangle Centers</title>
    <style>
        canvas {
            border: 1px solid black;
        }
        .info {
            margin-top: 10px;
        }
        .point-info {
            color: red; /* Default color */
        }
        .point-info.disabled {
            color: lightgray; /* Disabled state */
        }
        .circle-info {
            color: black; /* Default color */
        }
        .circle-info.disabled {
            color: lightgray; /* Disabled state */
        }
    </style>
</head>
<body>

<h2>Triangle Centers</h2>

<!-- Drawing area -->
<canvas id="triangleCanvas" width="1000" height="500"></canvas>

<!-- Information display -->
<div class="info">
    <p>Side lengths: AB = <span id="ab-length"></span>, BC = <span id="bc-length"></span>, CA = <span id="ca-length"></span></p>
    <p>Acute angles: ∠A = <span id="a-angle"></span>, ∠B = <span id="b-angle"></span>, ∠C = <span id="c-angle"></span></p>
    <p>Area: <span id="area"></span></p>
    <p>Centers</p>
    <p>
        <input type="checkbox" id="centroid-checkbox" checked> 
        <span id="centroid" class="point-info">● Centroid</span>
    </p>
    <p>
        <input type="checkbox" id="circumcenter-checkbox" checked> 
        <span id="circumcenter" class="point-info">● Circumcenter</span>
    </p>
    <p>
        <input type="checkbox" id="incenter-checkbox" checked> 
        <span id="incenter" class="point-info">● Incenter</span>
    </p>
    <p>
        <input type="checkbox" id="orthocenter-checkbox" checked> 
        <span id="orthocenter" class="point-info">● Orthocenter</span>
    </p>
    <p>
        <input type="checkbox" id="excenterA-checkbox" checked> 
        <span id="excenterA" class="point-info">● Excenter opposite to vertex A</span>
    </p>
    <p>
        <input type="checkbox" id="excenterB-checkbox" checked> 
        <span id="excenterB" class="point-info">● Excenter opposite to vertex B</span>
    </p>
    <p>
        <input type="checkbox" id="excenterC-checkbox" checked> 
        <span id="excenterC" class="point-info">● Excenter opposite to vertex C</span>
    </p>
    <p>
        <input type="checkbox" id="FermatPoint-checkbox" unchecked> 
        <span id="FermatPoint" class="point-info">● Fermat point</span>
    </p>
    <p>
        <input type="checkbox" id="deLongchampsPoint-checkbox" unchecked> 
        <span id="deLongchampsPoint" class="point-info">● de Longchamps point</span>
    </p>
    <p>
        <input type="checkbox" id="ninePointCenter-checkbox" unchecked> 
        <span id="ninePointCenter" class="point-info">● Nine-point center</span>
    </p>
    <p>
        <input type="checkbox" id="firstNapoleonPoint-checkbox" unchecked> 
        <span id="firstNapoleonPoint" class="point-info">● First Napoleon point</span>
    </p>
    <p>
        <input type="checkbox" id="secondNapoleonPoint-checkbox" unchecked> 
        <span id="secondNapoleonPoint" class="point-info">● Second Napoleon point</span>
    </p>
    <p>
        <input type="checkbox" id="LemoinePoint-checkbox" unchecked> 
        <span id="LemoinePoint" class="point-info">● Lemoine point</span>
    </p>
    <p>Circles</p>
    <p>
        <input type="checkbox" id="incircle-checkbox"  unchecked> 
        <span id="incircle" class="circle-info">○ Incircle</span>
    </p>
    <p>
        <input type="checkbox" id="circumcircle-checkbox" unchecked> 
        <span id="circumcircle" class="circle-info">○ Circumcircle</span>
    </p>
    <p>
        <input type="checkbox" id="excircleA-checkbox" unchecked> 
        <span id="excircleA" class="circle-info">○ Excircle opposite to vertex A</span>
    </p>
    <p>
        <input type="checkbox" id="excircleB-checkbox" unchecked> 
        <span id="excircleB" class="circle-info">○ Excircle opposite to vertex B</span>
    </p>
    <p>
        <input type="checkbox" id="excircleC-checkbox" unchecked> 
        <span id="excircleC" class="circle-info">○ Excircle opposite to vertex C</span>
    </p>
    <p>
        <input type="checkbox" id="ninePointCircle-checkbox" unchecked> 
        <span id="ninePointCircle" class="circle-info">○ Nine-point circle</span>
    </p>
    <p>Triangles</p>
    <p>
        <input type="checkbox" id="outerNapoleonTriangle-checkbox" unchecked> 
        <span id="outerNapoleonTriangle" class="circle-info">△ Outer Napoleon triangle</span>
    </p>
    <p>
        <input type="checkbox" id="innerNapoleonTriangle-checkbox" unchecked> 
        <span id="innerNapoleonTriangle" class="circle-info">△ Inner Napoleon triangle</span>
    </p>    
</div>

<script>
// Define styles for centers
const pointStyles = {
    centroid: {
        activeColor: 'blue',
        inactiveColor: 'lightgray',
        pointSymbol: '●',
        checkboxId: 'centroid-checkbox',
        displayElementId: 'centroid',
    },
    circumcenter: {
        activeColor: 'red',
        inactiveColor: 'lightgray',
        pointSymbol: '●',
        checkboxId: 'circumcenter-checkbox',
        displayElementId: 'circumcenter',
    },
    incenter: {
        activeColor: 'green',
        inactiveColor: 'lightgray',
        pointSymbol: '●',
        checkboxId: 'incenter-checkbox',
        displayElementId: 'incenter',
    },
    orthocenter: {
        activeColor: 'purple',
        inactiveColor: 'lightgray',
        pointSymbol: '●',
        checkboxId: 'orthocenter-checkbox',
        displayElementId: 'orthocenter',
    },
    excenterA: {
        activeColor: 'orange',
        inactiveColor: 'lightgray',
        pointSymbol: '●',
        checkboxId: 'excenterA-checkbox',
        displayElementId: 'excenterA',
    },
    excenterB: {
        activeColor: 'orange',
        inactiveColor: 'lightgray',
        pointSymbol: '●',
        checkboxId: 'excenterB-checkbox',
        displayElementId: 'excenterB',
    },
    excenterC: {
        activeColor: 'orange',
        inactiveColor: 'lightgray',
        pointSymbol: '●',
        checkboxId: 'excenterC-checkbox',
        displayElementId: 'excenterC',
    },
    FermatPoint: {
        activeColor: 'gray',
        inactiveColor: 'lightgray',
        pointSymbol: '●',
        checkboxId: 'FermatPoint-checkbox',
        displayElementId: 'FermatPoint',
    },
    deLongchampsPoint: {
        activeColor: '#c54ea0',
        inactiveColor: 'lightgray',
        pointSymbol: '●',
        checkboxId: 'deLongchampsPoint-checkbox',
        displayElementId: 'deLongchampsPoint',
    },
    ninePointCenter: {
        activeColor: 'lightblue',
        inactiveColor: 'lightgray',
        pointSymbol: '●',
        checkboxId: 'ninePointCenter-checkbox',
        displayElementId: 'ninePointCenter',
    },
    firstNapoleonPoint: {
        activeColor: 'brown',
        inactiveColor: 'lightgray',
        pointSymbol: '●',
        checkboxId: 'firstNapoleonPoint-checkbox',
        displayElementId: 'firstNapoleonPoint',
    },
    secondNapoleonPoint: {
        activeColor: '#c5956b',
        inactiveColor: 'lightgray',
        pointSymbol: '●',
        checkboxId: 'secondNapoleonPoint-checkbox',
        displayElementId: 'secondNapoleonPoint',
    },
    LemoinePoint: {
        activeColor: 'gold',
        inactiveColor: 'lightgray',
        pointSymbol: '●',
        checkboxId: 'LemoinePoint-checkbox',
        displayElementId: 'LemoinePoint',
    },
};

// Define styles for circles
const circleStyles = {
    incircle: {
        activeColor: 'green',
        inactiveColor: 'lightgray',
        checkboxId: 'incircle-checkbox',
        displayElementId: 'incircle',
    },
    circumcircle: {
        activeColor: 'red',
        inactiveColor: 'lightgray',
        checkboxId: 'circumcircle-checkbox',
        displayElementId: 'circumcircle',
    },
    excircleA: {
        activeColor: 'orange',
        inactiveColor: 'lightgray',
        checkboxId: 'excircleA-checkbox',
        displayElementId: 'excircleA',
    },
    excircleB: {
        activeColor: 'orange',
        inactiveColor: 'lightgray',
        checkboxId: 'excircleB-checkbox',
        displayElementId: 'excircleB',
    },
    excircleC: {
        activeColor: 'orange',
        inactiveColor: 'lightgray',
        checkboxId: 'excircleC-checkbox',
        displayElementId: 'excircleC',
    },
    ninePointCircle: {
        activeColor: 'lightblue',
        inactiveColor: 'lightgray',
        checkboxId: 'ninePointCircle-checkbox',
        displayElementId: 'ninePointCircle',
    },
};

// Define styles for triangles
const triangleStyles = {
    outerNapoleonTriangle: {
        activeColor: 'brown',
        inactiveColor: 'lightgray',
        checkboxId: 'outerNapoleonTriangle-checkbox',
        displayElementId: 'outerNapoleonTriangle',
    },
    innerNapoleonTriangle: {
        activeColor: '#c5956b',
        inactiveColor: 'lightgray',
        checkboxId: 'innerNapoleonTriangle-checkbox',
        displayElementId: 'innerNapoleonTriangle',
    },
};

// Triangle vertices
let points = [
    { x: 300, y: 100 }, // A
    { x: 200, y: 273.20508 }, // B
    { x: 400, y: 273.20508 }  // C
];

let selectedPoint = null;
const scaleFactor = 0.01; // Factor to scale down distances

// Canvas and context for drawing
const canvas = document.getElementById('triangleCanvas');
const ctx = canvas.getContext('2d');

// Initial drawing
reDraw();

// Function to draw the triangle
function drawOriginalTriangle() {
    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
    ctx.beginPath();
    ctx.strokeStyle = 'black'
    ctx.moveTo(points[0].x, points[0].y);
    ctx.lineTo(points[1].x, points[1].y);
    ctx.lineTo(points[2].x, points[2].y);
    ctx.closePath();
    ctx.stroke();

    // Draw vertices and labels
    points.forEach((point, index) => {
        drawPoint(point, ['A', 'B', 'C'][index]);
    });
}

function drawCenters(){
    // Draw points based on checkbox state
    if (document.getElementById('centroid-checkbox').checked) {
        const centroid = calculateCentroid(points[0], points[1], points[2]);
        drawPoint(centroid, 'Centroid', pointStyles.centroid.activeColor);
    }
    if (document.getElementById('circumcenter-checkbox').checked) {
        const circumcenter = calculateCircumcenter();
        drawPoint(circumcenter, 'Circumcenter', pointStyles.circumcenter.activeColor);
    }
    if (document.getElementById('incenter-checkbox').checked) {
        const incenter = calculateIncenter();
        drawPoint(incenter, 'Incenter', pointStyles.incenter.activeColor);
    }
    if (document.getElementById('orthocenter-checkbox').checked) {
        const orthocenter = calculateOrthocenter();
        drawPoint(orthocenter, 'Orthocenter', pointStyles.orthocenter.activeColor);
    }
    if (document.getElementById('excenterA-checkbox').checked) {
        const excenter = calculateExcenter(points[0], points[1], points[2]);
        drawPoint(excenter, 'Excenter (A)', pointStyles.excenterA.activeColor);
    }
    if (document.getElementById('excenterB-checkbox').checked) {
        const excenter = calculateExcenter(points[1], points[0], points[2]);
        drawPoint(excenter, 'Excenter (B)', pointStyles.excenterB.activeColor);
    }
    if (document.getElementById('excenterC-checkbox').checked) {
        const excenter = calculateExcenter(points[2], points[0], points[1]);
        drawPoint(excenter, 'Excenter (C)', pointStyles.excenterC.activeColor);
    }
    if (document.getElementById('FermatPoint-checkbox').checked) {
        const FermatPoint = calculateFermatPoint();
        drawPoint(FermatPoint, 'Fermat', pointStyles.FermatPoint.activeColor);
    }
    if (document.getElementById('deLongchampsPoint-checkbox').checked) {
        const deLongchampsPoint = calculateDeLongchampsPoint();
        drawPoint(deLongchampsPoint, 'deLongchampsPoint', pointStyles.deLongchampsPoint.activeColor);
    }
    if (document.getElementById('ninePointCenter-checkbox').checked) {
        const ninePointCenter = calculateNinePointCenter();
        drawPoint(ninePointCenter, 'Nine-point', pointStyles.ninePointCenter.activeColor);
    }
    if (document.getElementById('firstNapoleonPoint-checkbox').checked) {
        const firstNapoleonPoint = calculateNapoleonPoint(outer = true);
        drawPoint(firstNapoleonPoint, '1st Napoleon', pointStyles.firstNapoleonPoint.activeColor);
    }
    if (document.getElementById('secondNapoleonPoint-checkbox').checked) {
        const secondNapoleonPoint = calculateNapoleonPoint(outer = false);
        drawPoint(secondNapoleonPoint, '2nd Napoleon', pointStyles.secondNapoleonPoint.activeColor);
    }
    if (document.getElementById('LemoinePoint-checkbox').checked) {
        const LemoinePoint = calculateLemoinePoint();
        drawPoint(LemoinePoint, 'Lemoine', pointStyles.LemoinePoint.activeColor);
    }
}

function drawCircles(){
    // Draw points based on checkbox state
    if (document.getElementById('incircle-checkbox').checked) {
        const incircle = calculateIncircle();
        drawCircle(incircle, 'Incircle', circleStyles.incircle.activeColor);
    }
    if (document.getElementById('circumcircle-checkbox').checked) {
        const circumcircle = calculateCircumcircle();
        drawCircle(circumcircle, 'Circumcircle', circleStyles.circumcircle.activeColor);
    }
    if (document.getElementById('excircleA-checkbox').checked) {
        const excircleA = calculateExcircle(points[0], points[1], points[2]);
        drawCircle(excircleA, 'Excircle (A)', circleStyles.excircleA.activeColor);
    }
    if (document.getElementById('excircleB-checkbox').checked) {
        const excircleB = calculateExcircle(points[1], points[0], points[2]);
        drawCircle(excircleB, 'Excircle (B)', circleStyles.excircleB.activeColor);
    }
    if (document.getElementById('excircleC-checkbox').checked) {
        const excircleC = calculateExcircle(points[2], points[0], points[1]);
        drawCircle(excircleC, 'Excircle (C)', circleStyles.excircleC.activeColor);
    }
    if (document.getElementById('ninePointCircle-checkbox').checked) {
        const ninePointCircle = calculateNinePointCircle();
        drawCircle(ninePointCircle, 'Nine-point', circleStyles.ninePointCircle.activeColor);
    }
}

function drawTriangles(){
    // Draw points based on checkbox state
    if (document.getElementById('outerNapoleonTriangle-checkbox').checked) {
        const outerNapoleonTriangle = calculateNapoleonTriangle(outer = true);
        drawTriangle(outerNapoleonTriangle, 'Outer Napoleon', triangleStyles.outerNapoleonTriangle.activeColor);
    }
    if (document.getElementById('innerNapoleonTriangle-checkbox').checked) {
        const innerNapoleonTriangle = calculateNapoleonTriangle(outer = false);
        drawTriangle(innerNapoleonTriangle, 'Inner Napoleon', triangleStyles.innerNapoleonTriangle.activeColor);
    }
} 

// Function to draw a point and its label
function drawPoint(point, label = '', color = 'black') {
    ctx.beginPath();
    ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    
    // Draw the label near the point
    if (label){
        ctx.font = '16px Arial';
        ctx.fillStyle = color;
        ctx.fillText(label, point.x - 5, point.y + 20); // Adjust position for readability
    }
}

// Function to draw a circle
function drawCircle(circle, label = '', color = 'black') {
    ctx.beginPath();
    ctx.arc(circle.center.x, circle.center.y, circle.radius, 0, Math.PI * 2); // Draw a full circle
    ctx.strokeStyle = color;
    ctx.stroke();
    if (label){
        ctx.fillStyle = color;
        ctx.fillText(label, circle.center.x, circle.center.y);
    }
}

// Function to draw a triangle
function drawTriangle(triangle, label = '', color = 'black') {
    const [A, B, C] = triangle;

    // Draw the triangle
    ctx.beginPath();
    ctx.moveTo(A.x, A.y);
    ctx.lineTo(B.x, B.y);
    ctx.lineTo(C.x, C.y);
    ctx.closePath();
    ctx.strokeStyle = color;
    ctx.stroke();

    // Draw the label at the centroid of the triangle (or near one vertex)
    if (label) {
        const centroidX = (A.x + B.x + C.x) / 3;
        const centroidY = (A.y + B.y + C.y) / 3;
        ctx.fillStyle = color;
        ctx.fillText(label, centroidX, centroidY);
    }
}

// utils
function vectorSubtract(p1, p2) {
    return { x: p1.x - p2.x, y: p1.y - p2.y };
}

function dotProduct(v1, v2) {
    return v1.x * v2.x + v1.y * v2.y;
}

function magnitude(v) {
    return Math.sqrt(v.x * v.x + v.y * v.y);
}

function slope(p1, p2) {
    return (p2.y - p1.y) / (p2.x - p1.x)
}

function perpendicularSlope(slope) {
    // Handle cases where slopes might be 0 or undefined (vertical or horizontal lines)
    if (slope === 0) {
        return Infinity; // slope is horizontal, perpendicular is vertical
    } else if (!isFinite(slope)) {
        return 0; // slope is vertical, perpendicular is horizontal
    } else {
        return -1 / slope;
    }
}

// Function to rotate a point P around another point O by d degrees
// Be careful to consider the coordinates in canvas environment
function rotate(P, O, d) {
    const radian = Math.PI*d / 180;
    const dx = P.x - O.x;
    const dy = P.y - O.y;
    return {
        x: O.x + (dx * Math.cos(radian) - dy * Math.sin(radian)),
        y: O.y + (dx * Math.sin(radian) + dy * Math.cos(radian))
    };
}

// Function to find the intersection of two lines (P1, P2) and (Q1, Q2)
function lineIntersection(P1, P2, Q1, Q2) {
    const a1 = P2.y - P1.y;
    const b1 = P1.x - P2.x;
    const c1 = a1 * P1.x + b1 * P1.y;

    const a2 = Q2.y - Q1.y;
    const b2 = Q1.x - Q2.x;
    const c2 = a2 * Q1.x + b2 * Q1.y;

    const determinant = a1 * b2 - a2 * b1;

    if (determinant === 0) {
        return null; // Parallel lines
    } else {
        const x = (b2 * c1 - b1 * c2) / determinant;
        const y = (a1 * c2 - a2 * c1) / determinant;
        return { x, y };
    }
}

/**
 * This function calculates the intersection point of two lines, given their slopes and a point on each line.
 * The equations of the lines are derived using the point-slope form of a line equation: 
 * (y - y1) = m(x - x1), where m is the slope and (x1, y1) is a point on the line.
 * 
 * Parameters:
 *  - slope1: The slope of the first line.
 *  - point1: An object representing a point {x, y} on the first line.
 *  - slope2: The slope of the second line.
 *  - point2: An object representing a point {x, y} on the second line.
 * 
 * Returns:
 *  - An object {x, y} representing the intersection point of the two lines.
 *  - If the lines are parallel (i.e., the slopes are the same), the function returns null.
 */
 function lineIntersectionGivenSlopesAndPoints(slope1, point1, slope2, point2) {
    // Check if the lines are parallel by comparing the slopes
    if (slope1 === slope2) {
        return null; // Parallel lines do not intersect
    } else if (slope1 === Infinity) {
        // If the line1 is vertical
        const x = point1.x;
        const y = slope2 * (x - point2.x) + point2.y;
        return { x, y };
    } else if (slope2 === Infinity) {
        // If the line2 is vertical
        const x = point2.x;
        const y = slope1 * (x - point1.x) + point1.y;
        return { x, y };
    } else {
        // Calculate the intersection point using the point-slope formula
        const x = (slope1 * point1.x - point1.y - slope2 * point2.x + point2.y) / (slope1 - slope2);
        const y = slope1 * (x - point1.x) + point1.y;
        return { x, y };
    }
}

// Function to calculate the distance between two points
function calculateDistance(p1, p2) {
    return Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
}

// Function to calculate the acute angle at the middle point (B) given three points A, B, and C.
function calculateAngle(p1, p2, p3) {
    const v21 = vectorSubtract(p1, p2);
    const v23 = vectorSubtract(p3, p2);
    const cosTheta = dotProduct(v21, v23) / (magnitude(v21) * (magnitude(v23)));
    const thetaRad = Math.acos(cosTheta);
    return thetaRad * (180 / Math.PI);
}

// Function to calculate the area of the triangle
function calculateArea() {
    const [A, B, C] = points;
    return Math.abs((A.x * (B.y - C.y) + B.x * (C.y - A.y) + C.x * (A.y - B.y))) / 2;
}

// Function to calculate the centroid of the triangle
function calculateCentroid(A, B, C) {
    const x = ((A.x + B.x + C.x) / 3);
    const y = ((A.y + B.y + C.y) / 3);
    return { x, y };
}

// Function to calculate the circumcenter (intersection of perpendicular bisectors)
function calculateCircumcenter() {
    const [A, B, C] = points;

    // Midpoints of sides
    const D = { x: (A.x + B.x) / 2, y: (A.y + B.y) / 2 };
    const E = { x: (B.x + C.x) / 2, y: (B.y + C.y) / 2 };

    // Slopes of perpendicular bisectors
    const perpendicularSlopeAB = perpendicularSlope(slope(A, B));
    const perpendicularSlopeBC = perpendicularSlope(slope(B, C));

    // Circumcenter calculation
    return lineIntersectionGivenSlopesAndPoints(perpendicularSlopeAB, D, perpendicularSlopeBC, E);
}

// Function to calculate the incenter (intersection of angle bisectors)
function calculateIncenter() {
    const [A, B, C] = points;

    // Lengths of the sides
    const a = calculateDistance(B, C);
    const b = calculateDistance(A, C);
    const c = calculateDistance(A, B);

    // Incenter coordinates
    const x = (a * A.x + b * B.x + c * C.x) / (a + b + c);
    const y = (a * A.y + b * B.y + c * C.y) / (a + b + c);

    return { x, y };
}

// Function to calculate the orthocenter (intersection of perpendiculars)
function calculateOrthocenter() {
    const [A, B, C] = points;
    // Calculate perpendiculars
    const perpendicularSlopeAB = perpendicularSlope(slope(A, B));
    const perpendicularSlopeBC = perpendicularSlope(slope(B, C));

    // Solve for the intersection of the two perpendiculars (Orthocenter)
    return lineIntersectionGivenSlopesAndPoints(perpendicularSlopeAB, C, perpendicularSlopeBC, A);
}

// Function to calculate the excenter for the vertex A (intersection of the internal angle bisectors of the vertex and other external angle bisectors)
function calculateExcenter(A, B, C) {
    // Lengths of the triangle sides opposite to each vertex
    const a =  calculateDistance(B, C); // Length of side BC
    const b =  calculateDistance(A, C); // Length of side CA
    const c =  calculateDistance(A, B); // Length of side AB

    // Excenter formula for vertex p (opposite to side BC)
    const x = (-a * A.x + b * B.x + c * C.x) / (-a + b + c);
    const y = (-a * A.y + b * B.y + c * C.y) / (-a + b + c);

    return {x, y};
}

// Function to calculate the Fermat point such that the sum of the distances from three vertices to the point is the smallest
function calculateFermatPoint() {
    const [A, B, C] = points;
    
    // Check for angles >= 120 degrees
    if (calculateAngle(B, A, C) >= 120) {
        return A;
    } else if (calculateAngle(A, B, C) >= 120) {
        return B;
    } else if (calculateAngle(A, C, B) >= 120) {
        return C;
    }

    // Determine rotation direction based on the cross product of vectors AB and AC
    const crossProduct = (B.x - A.x) * (C.y - A.y) - (B.y - A.y) * (C.x - A.x);
    var rotateRadian = 0;
    if (crossProduct > 0){
        rotateRadian = -60;
    }
    else {
        rotateRadian = 60;
    }
    // Calculate rotation points for Fermat point
    const R1 = rotate(B, A, rotateRadian); // Rotate B 60 degrees around A
    const R2 = rotate(C, A, -rotateRadian); // Rotate C 60 degrees around A

    // Intersection of lines BR2 and CR1 gives the Fermat point
    return lineIntersection(B, R2, C, R1);
}

// Function to calculate the de Longchamps point that is the reflection of the orthocenter of the triangle about the circumcenter
function calculateDeLongchampsPoint() {
    const [A, B, C] = points;
    const orthocenter = calculateOrthocenter();
    const circumcenter = calculateCircumcenter();
    return {
        x: 2 * circumcenter.x - orthocenter.x,
        y: 2 * circumcenter.y - orthocenter.y,
    }
}

// Function to calculate the nine point center
function calculateNinePointCenter() {
    // Calculate the center and radius
    // The center is the midpoint between the orthocenter and circumcenter.
    // The radius is half of the circumradius.
    const orthocenter = calculateOrthocenter();
    const circumcircle = calculateCircumcircle();
    const circumcenter = circumcircle.center;
    return {
        x: (orthocenter.x + circumcenter.x)/2,
        y: (orthocenter.y + circumcenter.y)/2
    };
}

// Function to calculate the Napoleon points
function calculateNapoleonPoint(outer = true) {
    const [A, B, C] = points;
    const [D, E, F] = calculateNapoleonTriangle(outer = outer);
    return lineIntersection(A, D, B, E);
}

// Function to calculate the Lemoine point
function calculateLemoinePoint() {
    const [A, B, C] = points;
    // The circumcircle of triangle ABC and the tangents at each vertex.
    const circumcenter = calculateCircumcenter();
    const tangentSlopeA = perpendicularSlope(slope(circumcenter, A));
    const tangentSlopeB = perpendicularSlope(slope(circumcenter, B));
    const tangentSlopeC = perpendicularSlope(slope(circumcenter, C));
    // calculate symmedians
    const P1 = lineIntersectionGivenSlopesAndPoints(tangentSlopeB, B, tangentSlopeC, C);
    const P2 = lineIntersectionGivenSlopesAndPoints(tangentSlopeA, A, tangentSlopeC, C);
    return lineIntersection(A, P1, B, P2);
}


// Function to calculate the incircle
function calculateIncircle() {
    const [A, B, C] = points;
    
    // Calculate the incenter (already defined)
    const incenter = calculateIncenter();

    // Calculate the radius of the incircle using the formula: 2 * area / (a + b + c)
    const a = calculateDistance(B, C);
    const b = calculateDistance(C, A);
    const c = calculateDistance(A, B);
    const area = calculateArea();
    const radius = 2 * area / (a + b + c);

    // Return the circle object with center and radius
    return {
        center: incenter,
        radius: radius
    };
}


// Function to calculate the circumcircle
function calculateCircumcircle() {
    const [A, B, C] = points;
    
    // Calculate the circumcenter (already defined)
    const center = calculateCircumcenter();

    // Calculate the circumradius using the formula R = (a * b * c) / (4 * area)
    const a = calculateDistance(B, C);
    const b = calculateDistance(A, C);
    const c = calculateDistance(A, B);
    const area = calculateArea();
    const radius = (a * b * c) / (4 * area);

    // Return the circle object with center and radius
    return {
        center: center,
        radius: radius
    };
}

// Function to calculate the excircle opposite to the vertex A
function calculateExcircle(A, B, C) {
    // Calculate the center (already defined)
    const center = calculateExcenter(A, B, C);

    // Calculate the radius using the formula: 2 * area / (-a + b + c)
    const a = calculateDistance(B, C);
    const b = calculateDistance(C, A);
    const c = calculateDistance(A, B);
    const area = calculateArea();
    const radius = 2 * area / (-a + b + c);

    // Return the circle object with center and radius
    return {
        center: center,
        radius: radius
    };
}

// Function to calculate the nine-point circle
function calculateNinePointCircle() {
    const [A, B, C] = points;

    // Calculate the center and radius
    // The center is the midpoint between the orthocenter and circumcenter.
    // The radius is half of the circumradius.
    const circumcircle = calculateCircumcircle();

    // Return the circle object with center and radius
    return {
        center: calculateNinePointCenter(),
        radius: circumcircle.radius / 2
    };
}

// Function to calculate the outer Napoleon triangle
function calculateNapoleonTriangle(outer = true) {
    const [A, B, C] = points;

    // Calculate the outer equilateral triangle on each side
    const crossProductAB_AC = (B.x - A.x) * (C.y - A.y) - (B.y - A.y) * (C.x - A.x);

    // Determine rotation direction based on cross products
    let rotationRadian = crossProductAB_AC > 0 ? -60 : 60;
    if (!outer){
        rotationRadian = -rotationRadian; 
    }

    // Create equilateral triangles on each side
    const R1 = rotate(B, A, rotationRadian);
    const R2 = rotate(C, B, rotationRadian);
    const R3 = rotate(A, C, rotationRadian);

    // Return the points of the outer Napoleon triangle
    return [
        calculateCentroid(B, C, R2),
        calculateCentroid(C, A, R3),
        calculateCentroid(A, B, R1)
    ];
}


// Function to update the information display
function updateInfo() {
    const [A, B, C] = points;

    // Side lengths
    document.getElementById('ab-length').textContent = (calculateDistance(A, B) * scaleFactor).toFixed(2);
    document.getElementById('bc-length').textContent = (calculateDistance(B, C) * scaleFactor).toFixed(2);
    document.getElementById('ca-length').textContent = (calculateDistance(C, A) * scaleFactor).toFixed(2);

    // Acute angles
    document.getElementById('a-angle').textContent = calculateAngle(B, A, C).toFixed(2);
    document.getElementById('b-angle').textContent = calculateAngle(A, B, C).toFixed(2);
    document.getElementById('c-angle').textContent = calculateAngle(A, C, B).toFixed(2);

    // Area
    document.getElementById('area').textContent = (calculateArea() * scaleFactor**2).toFixed(2);
}

// Function to apply styles based on checkbox state
function applyStyles() {
    Object.keys(pointStyles).forEach(key => {
        const style = pointStyles[key];
        const checkbox = document.getElementById(style.checkboxId);
        const displayElement = document.getElementById(style.displayElementId);

        if (checkbox.checked) {
            displayElement.style.color = style.activeColor;
            displayElement.classList.remove('disabled');
        } else {
            displayElement.style.color = style.inactiveColor;
            displayElement.classList.add('disabled');
        }
    });
    Object.keys(circleStyles).forEach(key => {
        const style = circleStyles[key];
        const checkbox = document.getElementById(style.checkboxId);
        const displayElement = document.getElementById(style.displayElementId);

        if (checkbox.checked) {
            displayElement.style.color = style.activeColor;
            displayElement.classList.remove('disabled');
        } else {
            displayElement.style.color = style.inactiveColor;
            displayElement.classList.add('disabled');
        }
    });
    Object.keys(triangleStyles).forEach(key => {
        const style = triangleStyles[key];
        const checkbox = document.getElementById(style.checkboxId);
        const displayElement = document.getElementById(style.displayElementId);

        if (checkbox.checked) {
            displayElement.style.color = style.activeColor;
            displayElement.classList.remove('disabled');
        } else {
            displayElement.style.color = style.inactiveColor;
            displayElement.classList.add('disabled');
        }
    });
}

// Function to redraw the canvas
function reDraw(){
    drawOriginalTriangle();
    drawCenters();
    drawCircles();
    drawTriangles();
    updateInfo();
    applyStyles();
}

// Mouse events
canvas.addEventListener('mousedown', (e) => {
    const mouseX = e.offsetX;
    const mouseY = e.offsetY;
    selectedPoint = getSelectedPoint(mouseX, mouseY);
});

canvas.addEventListener('mousemove', (e) => {
    if (selectedPoint) {
        selectedPoint.x = e.offsetX;
        selectedPoint.y = e.offsetY;
        requestAnimationFrame(reDraw);
    }
});

canvas.addEventListener('mouseup', () => {
    selectedPoint = null;
});

// Function to check if a point is being dragged
function getSelectedPoint(mouseX, mouseY) {
    return points.find(point => {
        const dist = Math.sqrt((point.x - mouseX) ** 2 + (point.y - mouseY) ** 2);
        return dist < 10; // If within 10px, select the point
    });
}


// Touch events
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault(); // Prevent page scroll on touch start
    const touch = e.touches[0]; // First touch point
    const rect = canvas.getBoundingClientRect();
    const touchX = touch.clientX - rect.left;
    const touchY = touch.clientY - rect.top;
    selectedPoint = getSelectedPoint(touchX, touchY);
});

canvas.addEventListener('touchmove', (e) => {
    if (selectedPoint) {
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        selectedPoint.x = touch.clientX - rect.left;
        selectedPoint.y = touch.clientY - rect.top;
        requestAnimationFrame(reDraw); // Use requestAnimationFrame for smoother updates
    }
    e.preventDefault(); // Prevent scrolling while dragging
});

canvas.addEventListener('touchend', () => {
    selectedPoint = null;
});


// Event listeners for checkboxes
const pointCheckboxIds = Object.values(pointStyles).map(style => style.checkboxId);
const circleCheckboxIds = Object.values(circleStyles).map(style => style.checkboxId);
const triangleCheckboxIds = Object.values(triangleStyles).map(style => style.checkboxId);
const allCheckboxIds = [...pointCheckboxIds, ...circleCheckboxIds, ...triangleCheckboxIds];
allCheckboxIds.forEach(id => {
    document.getElementById(id).addEventListener('change', () => {
        reDraw();
    });
});

// Initial application of styles
applyStyles();
</script>

</body>
</html>
