<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Triangle Centers</title>
    <style>
        canvas {
            border: 1px solid black;
        }
        .info {
            margin-top: 10px;
        }
        .center-info {
            color: black; /* Default color */
        }
        .center-info.disabled {
            color: lightgray; /* Disabled state */
        }
        .line-info {
            color: black; /* Default color */
        }
        .line-info.disabled {
            color: lightgray; /* Disabled state */
        }
        .triangle-info {
            color: black; /* Default color */
        }
        .triangle-info.disabled {
            color: lightgray; /* Disabled state */
        }
        .hexagon-info {
            color: black; /* Default color */
        }
        .hexagon-info.disabled {
            color: lightgray; /* Disabled state */
        }
        .circle-info {
            color: black; /* Default color */
        }
        .circle-info.disabled {
            color: lightgray; /* Disabled state */
        }
        .ellipse-info {
            color: black; /* Default color */
        }
        .ellipse-info.disabled {
            color: lightgray; /* Disabled state */
        }
    </style>
</head>
<body>

<h2>Triangle Centers</h2>

<!-- Drawing area -->
<canvas id="triangleCanvas"></canvas>

<!-- Information display -->
<div class="info">
    <p>Side lengths: AB = <span id="ab-length"></span>, BC = <span id="bc-length"></span>, CA = <span id="ca-length"></span></p>
    <p>Angles: ∠A = <span id="a-angle"></span>, ∠B = <span id="b-angle"></span>, ∠C = <span id="c-angle"></span></p>
    <p>Area: <span id="area"></span></p>
    <p>
        <button id="uncheck-all-btn">Uncheck all checkboxes</button>
    </p>
    <p>Points and centers</p>
    <div id="centers-section"></div>
    <p>Lines</p>
    <div id="lines-section"></div>
    <p>Triangles</p>
    <div id="triangles-section"></div>
    <p>Hexagons</p>
    <div id="hexagons-section"></div>
    <p>Parabolas</p>
    <div id="parabolas-section"></div>
    <p>Circles</p>
    <div id="circles-section"></div>
    <p>Ellipses</p>
    <div id="ellipses-section"></div>
</div>

<script>
// Define styles for centers
// ETCReference is the reference number of the encyclopedia of triangle centers (ETC)
const centerStyles = {
    // excenterA: {
    //     activeColor: '#ee7800',
    //     inactiveColor: 'lightgray', 
    //     checkboxId: 'excenterA-checkbox',
    //     displayElementId: 'excenterA',
    //     annotationLabel: 'Excenter (A)',
    //     informationText: '● Excenter opposite to vertex A',
    // },
    // excenterB: {
    //     activeColor: '#ee7800',
    //     inactiveColor: 'lightgray', 
    //     checkboxId: 'excenterB-checkbox',
    //     displayElementId: 'excenterB',
    //     annotationLabel: 'Excenter (B)',
    //     informationText: '● Excenter opposite to vertex B',
    // },
    // excenterC: {
    //     activeColor: '#ee7800',
    //     inactiveColor: 'lightgray', 
    //     checkboxId: 'excenterC-checkbox',
    //     displayElementId: 'excenterC',
    //     annotationLabel: 'Excenter (C)',
    //     informationText: '● Excenter opposite to vertex C',
    // },
    excenters: {
        activeColor: '#ee7800',
        inactiveColor: 'lightgray', 
        checkboxId: 'excenters-checkbox',
        displayElementId: 'excenters',
        annotationLabel: 'Excenter',
        informationText: '● Excenters',
    },
    firstBrocardPoint: {
        activeColor: '#808080',
        inactiveColor: 'lightgray', 
        checkboxId: 'firstBrocardPoint-checkbox',
        displayElementId: 'firstBrocardPoint',
        annotationLabel: '1st Brocard',
        informationText: '● First Brocard point',
    },
    secondBrocardPoint: {
        activeColor: '#808080',
        inactiveColor: 'lightgray', 
        checkboxId: 'secondBrocardPoint-checkbox',
        displayElementId: 'secondBrocardPoint',
        annotationLabel: '2nd Brocard',
        informationText: '● Second Brocard point',
    },
    incenter: {
        activeColor: '#008000',
        inactiveColor: 'lightgray', 
        checkboxId: 'incenter-checkbox',
        displayElementId: 'incenter',
        annotationLabel: 'Incenter',
        informationText: '● Incenter',
        ETCReference: 1,
    },
    centroid: {
        activeColor: '#0000FF',
        inactiveColor: 'lightgray', 
        checkboxId: 'centroid-checkbox',
        displayElementId: 'centroid',
        annotationLabel: 'Centroid',
        informationText: '● Centroid',
        ETCReference: 2,
    },
    circumcenter: {
        activeColor: '#ff0000',
        inactiveColor: 'lightgray', 
        checkboxId: 'circumcenter-checkbox',
        displayElementId: 'circumcenter',
        annotationLabel: 'Circumcenter',
        informationText: '● Circumcenter',
        ETCReference: 3,
    },
    orthocenter: {
        activeColor: '#884898',
        inactiveColor: 'lightgray', 
        checkboxId: 'orthocenter-checkbox',
        displayElementId: 'orthocenter',
        annotationLabel: 'Orthocenter',
        informationText: '● Orthocenter',
        ETCReference: 4,
    },
    ninePointCenter: {
        activeColor: '#add8e6',
        inactiveColor: 'lightgray', 
        checkboxId: 'ninePointCenter-checkbox',
        displayElementId: 'ninePointCenter',
        annotationLabel: 'Nine-point',
        informationText: '● Nine-point center',
        ETCReference: 5,
    },
    symmedianPoint: {
        activeColor: '#ffd700',
        inactiveColor: 'lightgray', 
        checkboxId: 'symmedianPoint-checkbox',
        displayElementId: 'symmedianPoint',
        annotationLabel: 'Symmedian',
        informationText: '● Symmedian point (Lemoine point, Grebe point)',
        ETCReference: 6,
    },
    GergonnePoint: {
        activeColor: '#808080',
        inactiveColor: 'lightgray', 
        checkboxId: 'GergonnePoint-checkbox',
        displayElementId: 'GergonnePoint',
        annotationLabel: 'Gergonne',
        informationText: '● Gergonne point',
        ETCReference: 7,
    },
    NagelPoint: {
        activeColor: '#808080',
        inactiveColor: 'lightgray', 
        checkboxId: 'NagelPoint-checkbox',
        displayElementId: 'NagelPoint',
        annotationLabel: 'Nagel',
        informationText: '● Nagel point',
        ETCReference: 8,
    },
    Mittenpunkt: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'Mittenpunkt-checkbox',
        displayElementId: 'Mittenpunkt',
        annotationLabel: 'Mittenpunkt',
        informationText: '● Mittenpunkt',
        ETCReference: 9,
    },
    SpiekerCenter: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'SpiekerCenter-checkbox',
        displayElementId: 'SpiekerCenter',
        annotationLabel: 'Spieker',
        informationText: '● Spieker center',
        ETCReference: 10,
    },
    FeuerbachPoint: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'FeuerbachPoint-checkbox',
        displayElementId: 'FeuerbachPoint',
        annotationLabel: 'Feuerbach',
        informationText: '● Feuerbach point',
        ETCReference: 11,
    },
    firstIsogonicCenter: {
        activeColor: '#808080',
        inactiveColor: 'lightgray', 
        checkboxId: 'firstIsogonicCenter-checkbox',
        displayElementId: 'firstIsogonicCenter',
        annotationLabel: '1st isogonic',
        informationText: '● First isogonic center',
        ETCReference: 13,
    },
    FermatPoint: {
        activeColor: '#808080',
        inactiveColor: 'lightgray', 
        checkboxId: 'FermatPoint-checkbox',
        displayElementId: 'FermatPoint',
        annotationLabel: 'Fermat',
        informationText: '● Fermat point',
        ETCReference: 13,
    },
    secondIsogonicCenter: {
        activeColor: '#808080',
        inactiveColor: 'lightgray', 
        checkboxId: 'secondIsogonicCenter-checkbox',
        displayElementId: 'secondIsogonicCenter',
        annotationLabel: '2nd isogonic',
        informationText: '● Second isogonic center',
        ETCReference: 14,
    },
    firstIsodynamicPoint: {
        activeColor: '#808080',
        inactiveColor: 'lightgray', 
        checkboxId: 'firstIsodynamicPoint-checkbox',
        displayElementId: 'firstIsodynamicPoint',
        annotationLabel: '1st isodynamic',
        informationText: '● First isodynamic point',
        ETCReference: 15,
    },
    secondIsodynamicPoint: {
        activeColor: '#808080',
        inactiveColor: 'lightgray', 
        checkboxId: 'secondIsodynamicPoint-checkbox',
        displayElementId: 'secondIsodynamicPoint',
        annotationLabel: '2nd isodynamic',
        informationText: '● Second isodynamic point',
        ETCReference: 16,
    },
    firstNapoleonPoint: {
        activeColor: '#008000',
        inactiveColor: 'lightgray', 
        checkboxId: 'firstNapoleonPoint-checkbox',
        displayElementId: 'firstNapoleonPoint',
        annotationLabel: '1st Napoleon',
        informationText: '● First Napoleon point',
        ETCReference: 17,
    },
    secondNapoleonPoint: {
        activeColor: '#0000FF',
        inactiveColor: 'lightgray', 
        checkboxId: 'secondNapoleonPoint-checkbox',
        displayElementId: 'secondNapoleonPoint',
        annotationLabel: '2nd Napoleon',
        informationText: '● Second Napoleon point',
        ETCReference: 18,
    },
    ClawsonPoint: {
        activeColor: '#808080',
        inactiveColor: 'lightgray', 
        checkboxId: 'ClawsonPoint-checkbox',
        displayElementId: 'ClawsonPoint',
        annotationLabel: 'Clawson',
        informationText: '● Clawson point',
        ETCReference: 19,
    },
    deLongchampsPoint: {
        activeColor: '#808080',
        inactiveColor: 'lightgray', 
        checkboxId: 'deLongchampsPoint-checkbox',
        displayElementId: 'deLongchampsPoint',
        annotationLabel: 'de Longchamps',
        informationText: '● de Longchamps point',
        ETCReference: 20,
    },
    SchifflerPoint: {
        activeColor: '#808080',
        inactiveColor: 'lightgray', 
        checkboxId: 'SchifflerPoint-checkbox',
        displayElementId: 'SchifflerPoint',
        annotationLabel: 'Schiffler',
        informationText: '● Schiffler point',
        ETCReference: 21,
    },
    ExeterPoint: {
        activeColor: '#808080',
        inactiveColor: 'lightgray', 
        checkboxId: 'ExeterPoint-checkbox',
        displayElementId: 'ExeterPoint',
        annotationLabel: 'Exeter',
        informationText: '● Exeter point',
        ETCReference: 22,
    },
    farOutPoint: {
        activeColor: '#808080',
        inactiveColor: 'lightgray', 
        checkboxId: 'farOutPoint-checkbox',
        displayElementId: 'farOutPoint',
        annotationLabel: 'Far-out',
        informationText: '● Far-out point',
        ETCReference: 23,
    },
    BrocardMidpoint: {
        activeColor: '#808080',
        inactiveColor: 'lightgray', 
        checkboxId: 'BrocardMidpoint-checkbox',
        displayElementId: 'BrocardMidpoint',
        annotationLabel: 'Brocard midpoint',
        informationText: '● Brocard midpoint',
        ETCReference: 39,
    },
    BevanPoint: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'BevanPoint-checkbox',
        displayElementId: 'BevanPoint',
        annotationLabel: 'Bevan',
        informationText: '● Bevan point',
        ETCReference: 40,
    },
    KosnitaPoint: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'KosnitaPoint-checkbox',
        displayElementId: 'KosnitaPoint',
        annotationLabel: 'Kosnita',
        informationText: '● Kosnita point',
        ETCReference: 54,
    },
    PrasolovPoint: {
        activeColor: '#808080',
        inactiveColor: 'lightgray', 
        checkboxId: 'PrasolovPoint-checkbox',
        displayElementId: 'PrasolovPoint',
        annotationLabel: 'Prasolov',
        informationText: '● Prasolov point',
        ETCReference: 68,
    },
    thirdBrocardPoint: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'thirdBrocardPoint-checkbox',
        displayElementId: 'thirdBrocardPoint',
        annotationLabel: '3rd Brocard',
        informationText: '● Third Brocard point',
        ETCReference: 76,
    },
    TarryPoint: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'TarryPoint-checkbox',
        displayElementId: 'TarryPoint',
        annotationLabel: 'Tarry',
        informationText: '● Tarry point',
        ETCReference: 98,
    },
    SteinerPoint: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'SteinerPoint-checkbox',
        displayElementId: 'SteinerPoint',
        annotationLabel: 'Steiner',
        informationText: '● Steiner point',
        ETCReference: 99,
    },
    focusOfKiepertParabola: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'focusOfKiepertParabola-checkbox',
        displayElementId: 'focusOfKiepertParabola',
        annotationLabel: 'Focus of Kiepert parabola',
        informationText: '● Focus of Kiepert parabola',
        ETCReference: 110,
    },
    ParryPoint: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'ParryPoint-checkbox',
        displayElementId: 'ParryPoint',
        annotationLabel: 'Parry',
        informationText: '● Parry point',
        ETCReference: 111,
    },
    firstAjimaMalfattiPoint: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'firstAjimaMalfattiPoint-checkbox',
        displayElementId: 'firstAjimaMalfattiPoint',
        annotationLabel: '1st Ajima-Malfatti',
        informationText: '● First Ajima-Malfatti point',
        ETCReference: 179,
    },
    secondAjimaMalfattiPoint: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'secondAjimaMalfattiPoint-checkbox',
        displayElementId: 'secondAjimaMalfattiPoint',
        annotationLabel: '2nd Ajima-Malfatti',
        informationText: '● Second Ajima-Malfatti point',
        ETCReference: 180,
    },
    equalParalleliansPoint: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'equalParalleliansPoint-checkbox',
        displayElementId: 'equalParalleliansPoint',
        annotationLabel: 'Equal parallelians',
        informationText: '● Equal parallelians point (Congruent parallelians point)',
        ETCReference: 192,
    },
    FuhrmannCenter: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'FuhrmannCenter-checkbox',
        displayElementId: 'FuhrmannCenter',
        annotationLabel: 'Fuhrmann',
        informationText: '● Fuhrmann center',
        ETCReference: 355,
    },
    firstKenmotuPoint: {
        activeColor: '#008000',
        inactiveColor: 'lightgray',
        checkboxId: 'firstKenmotuPoint-checkbox',
        displayElementId: 'firstKenmotuPoint',
        annotationLabel: '1st Kenmotu',
        informationText: '● First Kenmotu point (Congruent squares point)',
        ETCReference: 371,
    },
    secondKenmotuPoint: {
        activeColor: '#0000FF',
        inactiveColor: 'lightgray',
        checkboxId: 'secondKenmotuPoint-checkbox',
        displayElementId: 'secondKenmotuPoint',
        annotationLabel: '2nd Kenmotu',
        informationText: '● Second Kenmotu point',
        ETCReference: 372,
    },
    outerVectenPoint: {
        activeColor: '#008000',
        inactiveColor: 'lightgray',
        checkboxId: 'outerVectenPoint-checkbox',
        displayElementId: 'outerVectenPoint',
        annotationLabel: 'Outer Vecten',
        informationText: '● Outer Vecten point',
        ETCReference: 485,
    },
    innerVectenPoint: {
        activeColor: '#0000FF',
        inactiveColor: 'lightgray',
        checkboxId: 'innerVectenPoint-checkbox',
        displayElementId: 'innerVectenPoint',
        annotationLabel: 'Inner Vecten',
        informationText: '● Inner Vecten point',
        ETCReference: 486,
    },
    EvansPoint: {
        activeColor: '#808080',
        inactiveColor: 'lightgray', 
        checkboxId: 'EvansPoint-checkbox',
        displayElementId: 'EvansPoint',
        annotationLabel: 'Evans',
        informationText: '● Evans point',
        ETCReference: 1375,
    },
};

// Define styles for lines
const lineStyles = {
    sidelines: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'sidelines-checkbox',
        displayElementId: 'sidelines',
        annotationLabel: 'Sideline',
        informationText: '- Sidelines',
    },
    medians: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'medians-checkbox',
        displayElementId: 'medians',
        annotationLabel: 'Median',
        informationText: '- Medians',
    },
    perpendicularBisectors: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'perpendicularBisectors-checkbox',
        displayElementId: 'perpendicularBisectors',
        annotationLabel: 'perpendicular bisector',
        informationText: '- Perpendicular bisectors',
    },
    internalAngleBisectors: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'internalAngleBisectors-checkbox',
        displayElementId: 'internalAngleBisectors',
        annotationLabel: 'angle bisector',
        informationText: '- Internal angle bisectors',
    },
    altitudes: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: ' altitudes-checkbox',
        displayElementId: ' altitudes',
        annotationLabel: 'Altitude',
        informationText: '- Altitudes',
    },
    symmedians: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'symmedians-checkbox',
        displayElementId: 'symmedians',
        annotationLabel: 'Symmedian',
        informationText: '- Symmedians',
    },
    exsymmedians: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'exsymmedians-checkbox',
        displayElementId: 'exsymmedians',
        annotationLabel: 'Exsymmedian',
        informationText: '- Exsymmedians',
    },
    splitters: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'splitters-checkbox',
        displayElementId: 'splitters',
        annotationLabel: 'Splitter',
        informationText: '- Splitters',
    },
    cleavers: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'cleavers-checkbox',
        displayElementId: 'cleavers',
        annotationLabel: 'Cleaver',
        informationText: '- Cleavers',
    },
    EulerLine: {
        activeColor: '#ffd700',
        inactiveColor: 'lightgray',
        checkboxId: 'EulerLine-checkbox',
        displayElementId: 'EulerLine',
        annotationLabel: 'Euler',
        informationText: '- Euler line',
    },
    GergonneLine: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'GergonneLine-checkbox',
        displayElementId: 'GergonneLine',
        annotationLabel: 'Gergonne',
        informationText: '- Gergonne line',
    },
    NagelLine: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'NagelLine-checkbox',
        displayElementId: 'NagelLine',
        annotationLabel: 'Nagel',
        informationText: '- Nagel line',
    },
    vanAubelLine: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'vanAubelLine-checkbox',
        displayElementId: 'vanAubelLine',
        annotationLabel: 'van Aubel',
        informationText: '- van Aubel line',
    },
    BrocardAxis: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'BrocardAxis-checkbox',
        displayElementId: 'BrocardAxis',
        annotationLabel: 'Brocard axis',
        informationText: '- Brocard axis',
    },
    FermatAxis: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'FermatAxis-checkbox',
        displayElementId: 'FermatAxis',
        annotationLabel: 'Fermat axis',
        informationText: '- Fermat axis',
    },
    OrthicAxis: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'OrthicAxis-checkbox',
        displayElementId: 'OrthicAxis',
        annotationLabel: 'Orthic',
        informationText: '- Orthic axis',
    },
    OrthogonalRegressionLine: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'OrthogonalRegressionLine-checkbox',
        displayElementId: 'OrthogonalRegressionLine',
        annotationLabel: 'Orthogonal regression',
        informationText: '- Orthogonal regression line for the three vertices',
    },
};

// Define styles for triangles
const triangleStyles = {
    medialTriangle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'medialTriangle-checkbox',
        displayElementId: 'medialTriangle',
        annotationLabel: 'Medial',
        informationText: '△ Medial triangle',
    },
    excentralTriangle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'excentralTriangle-checkbox',
        displayElementId: 'excentralTriangle',
        annotationLabel: 'Excentral',
        informationText: '△ Excentral triangle',
    },
    intouchTriangle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'intouchTriangle-checkbox',
        displayElementId: 'intouchTriangle',
        annotationLabel: 'Intouch',
        informationText: '△ Intouch triangle (Contact triangle, Gergonne triangle)',
    },
    extouchTriangle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'extouchTriangle-checkbox',
        displayElementId: 'extouchTriangle',
        annotationLabel: 'Extouch',
        informationText: '△ Extouch triangle',
    },
    orthicTriangle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'orthicTriangle-checkbox',
        displayElementId: 'orthicTriangle',
        annotationLabel: 'Orthic',
        informationText: '△ Orthic triangle',
    },
    reflectionTriangle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'reflectionTriangle-checkbox',
        displayElementId: 'reflectionTriangle',
        annotationLabel: 'Reflection',
        informationText: '△ Reflection triangle',
    },
    tangentialTriangle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'tangentialTriangle-checkbox',
        displayElementId: 'tangentialTriangle',
        annotationLabel: 'Tangential',
        informationText: '△ Tangential triangle',
    },
    anticomplementaryTriangle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'anticomplementaryTriangle-checkbox',
        displayElementId: 'anticomplementaryTriangle',
        annotationLabel: 'Anticomplementary',
        informationText: '△ Anticomplementary triangle',
    },
    circumMedialTriangle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'circumMedialTriangle-checkbox',
        displayElementId: 'circumMedialTriangle',
        annotationLabel: 'Circum-medial',
        informationText: '△ Circum-medial triangle',
    },
    outerNapoleonTriangle: {
        activeColor: '#008000',
        inactiveColor: 'lightgray',
        checkboxId: 'outerNapoleonTriangle-checkbox',
        displayElementId: 'outerNapoleonTriangle',
        annotationLabel: 'Outer Napoleon',
        informationText: '△ Outer Napoleon triangle',
    },
    innerNapoleonTriangle: {
        activeColor: '#0000FF',
        inactiveColor: 'lightgray',
        checkboxId: 'innerNapoleonTriangle-checkbox',
        displayElementId: 'innerNapoleonTriangle',
        annotationLabel: 'Inner Napoleon',
        informationText: '△ Inner Napoleon triangle',
    },
    FuhrmannTriangle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'FuhrmannTriangle-checkbox',
        displayElementId: 'FuhrmannTriangle',
        annotationLabel: 'Fuhrmann',
        informationText: '△ Fuhrmann triangle',
    },
    FeuerbachTriangle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'FeuerbachTriangle-checkbox',
        displayElementId: 'FeuerbachTriangle',
        annotationLabel: 'Feuerbach',
        informationText: '△ Feuerbach triangle',
    },
    firstBrocardTriangle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'firstBrocardTriangle-checkbox',
        displayElementId: 'firstBrocardTriangle',
        annotationLabel: '1st Brocard',
        informationText: '△ First Brocard triangle',
    },
    secondBrocardTriangle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'secondBrocardTriangle-checkbox',
        displayElementId: 'secondBrocardTriangle',
        annotationLabel: '2nd Brocard',
        informationText: '△ Second Brocard triangle',
    },
    outerVectenTriangle: {
        activeColor: '#008000',
        inactiveColor: 'lightgray',
        checkboxId: 'outerVectenTriangle-checkbox',
        displayElementId: 'outerVectenTriangle',
        annotationLabel: 'Outer Vecten',
        informationText: '△ Outer Vecten triangle',
    },
    innerVectenTriangle: {
        activeColor: '#0000FF',
        inactiveColor: 'lightgray',
        checkboxId: 'innerVectenTriangle-checkbox',
        displayElementId: 'innerVectenTriangle',
        annotationLabel: 'Inner Vecten',
        informationText: '△ Inner Vecten triangle',
    },
    AymeTriangle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'AymeTriangle-checkbox',
        displayElementId: 'AymeTriangle',
        annotationLabel: 'Ayme',
        informationText: '△ Ayme triangle',
    },
    SteinerTriangle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'SteinerTriangle-checkbox',
        displayElementId: 'SteinerTriangle',
        annotationLabel: 'Steiner',
        informationText: '△ Steiner triangle',
    },
};

// Define styles for hexagon
const hexagonStyles = {
    firstLemoineHexagon: {
        activeColor: '#008000',
        inactiveColor: 'lightgray',
        checkboxId: 'firstLemoineHexagon-checkbox',
        displayElementId: 'firstLemoineHexagon',
        annotationLabel: '1st Lemoine',
        informationText: '⬡ First Lemoine hexagon',
    },
    secondLemoineHexagon: {
        activeColor: '#0000FF',
        inactiveColor: 'lightgray',
        checkboxId: 'secondLemoineHexagon-checkbox',
        displayElementId: 'secondLemoineHexagon',
        annotationLabel: '2nd Lemoine',
        informationText: '⬡ Second Lemoine hexagon',
    },
}


// Define styles for parabola
const parabolaStyles = {
    KiepertParabola: {
        activeColor: '#0000FF',
        inactiveColor: 'lightgray',
        checkboxId: 'KiepertParabola-checkbox',
        displayElementId: 'KiepertParabola',
        annotationLabel: 'Kiepert',
        informationText: '◡ Kiepert parabola',
    },
}


// Define styles for circles
const circleStyles = {
    // excircleA: {
    //     activeColor: '#ee7800',
    //     inactiveColor: 'lightgray',
    //     checkboxId: 'excircleA-checkbox',
    //     displayElementId: 'excircleA',
    //     annotationLabel: 'Excircle (A)',
    //     informationText: '○ Excircle opposite to vertex A',
    // },
    // excircleB: {
    //     activeColor: '#ee7800',
    //     inactiveColor: 'lightgray',
    //     checkboxId: 'excircleB-checkbox',
    //     displayElementId: 'excircleB',
    //     annotationLabel: 'Excircle (B)',
    //     informationText: '○ Excircle opposite to vertex B',
    // },
    // excircleC: {
    //     activeColor: '#ee7800',
    //     inactiveColor: 'lightgray',
    //     checkboxId: 'excircleC-checkbox',
    //     displayElementId: 'excircleC',
    //     annotationLabel: 'Excircle (C)',
    //     informationText: '○ Excircle opposite to vertex C',
    // },
    excircles: {
        activeColor: '#ee7800',
        inactiveColor: 'lightgray',
        checkboxId: 'excircles-checkbox',
        displayElementId: 'excircles',
        annotationLabel: 'Excircle',
        informationText: '○ Excircles',
    },
    incircle: {
        activeColor: '#008000',
        inactiveColor: 'lightgray',
        checkboxId: 'incircle-checkbox',
        displayElementId: 'incircle',
        annotationLabel: 'Incircle',
        informationText: '○ Incircle',
    },
    circumcircle: {
        activeColor: '#ff0000',
        inactiveColor: 'lightgray',
        checkboxId: 'circumcircle-checkbox',
        displayElementId: 'circumcircle',
        annotationLabel: 'Circumcircle',
        informationText: '○ Circumcircle',
    },
    ninePointCircle: {
        activeColor: '#add8e6',
        inactiveColor: 'lightgray',
        checkboxId: 'ninePointCircle-checkbox',
        displayElementId: 'ninePointCircle',
        annotationLabel: 'Nine-point',
        informationText: '○ Nine-point circle',
    },
    threeExternallyTangentCircles: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'threeExternallyTangentCircles-checkbox',
        displayElementId: 'threeExternallyTangentCircles',
        annotationLabel: 'Externally tangent circle',
        informationText: '○ Three externally tangent circles centered at its vertices',
    },
    orthocentroidalCircle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'orthocentroidalCircle-checkbox',
        displayElementId: 'orthocentroidalCircle',
        annotationLabel: 'Orthocentroidal',
        informationText: '○ Orthocentroidal circle',
    },
    smallestCircle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'smallestCircle-checkbox',
        displayElementId: 'smallestCircle',
        annotationLabel: 'Smallest-circle',
        informationText: '○ Smallest-circle that contains all vertices of the triangle',
    },
    LesterCircle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'LesterCircle-checkbox',
        displayElementId: 'LesterCircle',
        annotationLabel: 'Lester',
        informationText: '○ Lester circle',
    },
    BevanCircle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'BevanCircle-checkbox',
        displayElementId: 'BevanCircle',
        annotationLabel: 'Bevan',
        informationText: '○ Bevan circle',
    },
    SpiekerCircle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'SpiekerCircle-checkbox',
        displayElementId: 'SpiekerCircle',
        annotationLabel: 'Spieker',
        informationText: '○ Spieker circle',
    },
    AdamsCircle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'AdamsCircle-checkbox',
        displayElementId: 'AdamsCircle',
        annotationLabel: 'Adams\'',
        informationText: '○ Adams\' circle',
    },
    AdamsCircle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'AdamsCircle-checkbox',
        displayElementId: 'AdamsCircle',
        annotationLabel: 'Adams\'',
        informationText: '○ Adams\' circle',
    },
    FuhrmannCircle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'FuhrmannCircle-checkbox',
        displayElementId: 'FuhrmannCircle',
        annotationLabel: 'Fuhrmann',
        informationText: '○ Fuhrmann circle',
    },
    MandartCircle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'MandartCircle-checkbox',
        displayElementId: 'MandartCircle',
        annotationLabel: 'Mandart',
        informationText: '○ Mandart circle',
    },
    MalfattiCircles: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'MalfattiCircles-checkbox',
        displayElementId: 'MalfattiCircles',
        annotationLabel: 'Malfatti',
        informationText: '○ Malfatti circles',
    },
    ParryCircle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'ParryCircle-checkbox',
        displayElementId: 'ParryCircle',
        annotationLabel: 'Parry',
        informationText: '○ Parry circle',
    },
    BrocardCircle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'BrocardCircle-checkbox',
        displayElementId: 'BrocardCircle',
        annotationLabel: 'Brocard',
        informationText: '○ Brocard circle',
    },
    TaylorCircle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'TaylorCircle-checkbox',
        displayElementId: 'TaylorCircle',
        annotationLabel: 'Taylor',
        informationText: '○ Taylor circle',
    },
    VanLamoenCircle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'VanLamoenCircle-checkbox',
        displayElementId: 'VanLamoenCircle',
        annotationLabel: 'Van Lamoen',
        informationText: '○ Van Lamoen circle',
    },
    firstLemoineCircle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'firstLemoineCircle-checkbox',
        displayElementId: 'firstLemoineCircle',
        annotationLabel: '1st Lemoine',
        informationText: '○ First Lemoine circle',
    },
    cosineCircle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'cosineCircle-checkbox',
        displayElementId: 'cosineCircle',
        annotationLabel: 'Cosine',
        informationText: '○ Cosine circle (Second Lemoine circle)',
    },
    KenmotuCircle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'KenmotuCircle-checkbox',
        displayElementId: 'KenmotuCircle',
        annotationLabel: 'Kenmotu',
        informationText: '○ Kenmotu circle',
    },
    ConwayCircle: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'ConwayCircle-checkbox',
        displayElementId: 'ConwayCircle',
        annotationLabel: 'Conway',
        informationText: '○ Conway circle',
    },
    mixtilinearIncircles: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'mixtilinearIncircles-checkbox',
        displayElementId: 'mixtilinearIncircles',
        annotationLabel: 'Mixtilinear incircle',
        informationText: '○ Mixtilinear incircles',
    },
};

// Define styles for ellipse
const ellipseStyles = {
    SteinerInellipse: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'SteinerInellipse-checkbox',
        displayElementId: 'SteinerInellipse',
        annotationLabel: 'Steiner inellipse',
        informationText: '⬭ Steiner inellipse',
    },
    SteinerCircumellipse: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'SteinerCircumellipse-checkbox',
        displayElementId: 'SteinerCircumellipse',
        annotationLabel: 'Steiner circumellipse',
        informationText: '⬭ Steiner circumellipse',
    },
    LemoineInellipse: {
        activeColor: '#808080',
        inactiveColor: 'lightgray',
        checkboxId: 'LemoineInellipse-checkbox',
        displayElementId: 'LemoineInellipse',
        annotationLabel: 'Lemoine',
        informationText: '⬭ Lemoine inellipse',
    },
}

// Triangle vertices
let points = [
    { x: 300, y: 100 }, // A
    { x: 200, y: 273.20508 }, // B
    { x: 400, y: 273.20508 }  // C
];

let selectedPoint = null;
const scaleFactor = 0.01; // Factor to scale down distances
const epsilon = 1e-6; // Small tolerance value

// Canvas and context for drawing
const CANVAS_WIDTH = 1000;
const CANVAS_HEIGHT = 500;
const canvas = document.getElementById('triangleCanvas');
const ctx = canvas.getContext('2d');

/*
Whether to use trilinear coordinates and barycentric coodinates.
Using homogeneous coordinates reduces the computational cost, as it simplifies the process of calculating points
compared to more complex calculations like finding intersections between circles and lines. */
const useHomogeneousCoordinates = true;

// Combine all styles into one array of style objects
const allStyles = [
    ...Object.values(centerStyles),
    ...Object.values(lineStyles),
    ...Object.values(triangleStyles),
    ...Object.values(hexagonStyles),
    ...Object.values(parabolaStyles),
    ...Object.values(circleStyles),
    ...Object.values(ellipseStyles)
];
const allCheckboxIds = [
    ...Object.values(centerStyles).map(style => style.checkboxId),
    ...Object.values(lineStyles).map(style => style.checkboxId),
    ...Object.values(triangleStyles).map(style => style.checkboxId),
    ...Object.values(hexagonStyles).map(style => style.checkboxId),
    ...Object.values(parabolaStyles).map(style => style.checkboxId),
    ...Object.values(circleStyles).map(style => style.checkboxId),
    ...Object.values(ellipseStyles).map(style => style.checkboxId),
];

// Initial drawing
initializeStyles();
reDraw();

// Function to initialize styles (run once at the start)
function initializeStyles() {
    // Set canvas width and height using the constants
    const canvas = document.getElementById('triangleCanvas');
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;

    allStyles.forEach(style => {
        const displayElement = document.getElementById(style.displayElementId); // Get the element
        // Update the display text using informationText
        if (style.informationText && displayElement) {
            displayElement.textContent = style.informationText;
        }
    });
    createCheckboxes(Object.values(centerStyles), 'centers-section', 'center-info');
    createCheckboxes(Object.values(lineStyles), 'lines-section', 'line-info');
    createCheckboxes(Object.values(triangleStyles), 'triangles-section', 'triangle-info');
    createCheckboxes(Object.values(hexagonStyles), 'hexagons-section', 'hexagon-info');
    createCheckboxes(Object.values(parabolaStyles), 'parabolas-section', 'parabola-info');
    createCheckboxes(Object.values(circleStyles), 'circles-section', 'circle-info');
    createCheckboxes(Object.values(ellipseStyles), 'ellipses-section', 'ellipse-info');

    // Default the checkboxes for the five significant centers
    const defaultTrueCheckboxes = [
        // centerStyles.excenterA.checkboxId,
        // centerStyles.excenterB.checkboxId,
        // centerStyles.excenterC.checkboxId,
        centerStyles.excenters.checkboxId,
        centerStyles.incenter.checkboxId,
        centerStyles.centroid.checkboxId,
        centerStyles.circumcenter.checkboxId,
        centerStyles.orthocenter.checkboxId,
    ];

    defaultTrueCheckboxes.forEach(checkboxId => {
        const checkbox = document.getElementById(checkboxId);
        if (checkbox) {
            checkbox.checked = true;
        }
    });

}

// Function to redraw the canvas
function reDraw(){
    drawOriginalTriangle();
    drawCenters();
    drawLines();
    drawTriangles();
    drawHexagons();
    drawParabolas();
    drawCircles();
    drawEllipses();
    updateInfo();
    applyStyles();
}

// Function to update the information display
function updateInfo() {
    const [A, B, C] = points;

    // Side lengths
    document.getElementById('ab-length').textContent = (calculateDistance(A, B) * scaleFactor).toFixed(2);
    document.getElementById('bc-length').textContent = (calculateDistance(B, C) * scaleFactor).toFixed(2);
    document.getElementById('ca-length').textContent = (calculateDistance(C, A) * scaleFactor).toFixed(2);

    // Angles
    document.getElementById('a-angle').textContent = calculateAngleInDegrees(B, A, C).toFixed(2);
    document.getElementById('b-angle').textContent = calculateAngleInDegrees(A, B, C).toFixed(2);
    document.getElementById('c-angle').textContent = calculateAngleInDegrees(A, C, B).toFixed(2);

    // Area
    document.getElementById('area').textContent = (calculateArea(points) * scaleFactor**2).toFixed(2);
}

// Function to apply styles based on checkbox state
function applyStyles() {
    allStyles.forEach(style => {
        const checkbox = document.getElementById(style.checkboxId);
        const displayElement = document.getElementById(style.displayElementId);

        if (checkbox && displayElement) {
            if (checkbox.checked) {
                displayElement.style.color = style.activeColor;
                displayElement.classList.remove('disabled');
            } else {
                displayElement.style.color = style.inactiveColor;
                displayElement.classList.add('disabled');
            }
        }
    });
}

// Function to create checkboxes and add them to the correct section
function createCheckboxes(styleList, sectionId, className) {
    const section = document.getElementById(sectionId);

    styleList.forEach(style => {
        const p = document.createElement('p');

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = style.checkboxId;
        checkbox.checked = false;

        const span = document.createElement('span');
        span.id = style.displayElementId;
        span.className = className;
        span.textContent = style.informationText;

        // Create the color picker input
        const colorPicker = document.createElement('input');
        colorPicker.type = 'color';
        colorPicker.value = style.activeColor;  // Default value
        colorPicker.id = `${style.checkboxId}-color`; // Unique id for each color picker

        // Add an event listener to update the activeColor dynamically
        colorPicker.addEventListener('input', (e) => {
            style.activeColor = e.target.value;
            reDraw();  // Redraw the canvas with the updated color
        });        

        p.appendChild(checkbox);
        p.appendChild(colorPicker);
        p.appendChild(span);
        section.appendChild(p);
    });
}

// Mouse events
canvas.addEventListener('mousedown', (e) => {
    const mouseX = e.offsetX;
    const mouseY = e.offsetY;
    selectedPoint = getSelectedPoint(mouseX, mouseY);
});

canvas.addEventListener('mousemove', (e) => {
    if (selectedPoint) {
        selectedPoint.x = e.offsetX;
        selectedPoint.y = e.offsetY;
        requestAnimationFrame(reDraw);
    }
});

canvas.addEventListener('mouseup', () => {
    selectedPoint = null;
});

// Function to check if a point is being dragged
function getSelectedPoint(mouseX, mouseY) {
    return points.find(point => {
        const dist = Math.sqrt((point.x - mouseX) ** 2 + (point.y - mouseY) ** 2);
        return dist < 10; // If within 10px, select the point
    });
}

// Touch events
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault(); // Prevent page scroll on touch start
    const touch = e.touches[0]; // First touch point
    const rect = canvas.getBoundingClientRect();
    const touchX = touch.clientX - rect.left;
    const touchY = touch.clientY - rect.top;
    selectedPoint = getSelectedPoint(touchX, touchY);
});

canvas.addEventListener('touchmove', (e) => {
    if (selectedPoint) {
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        selectedPoint.x = touch.clientX - rect.left;
        selectedPoint.y = touch.clientY - rect.top;
        requestAnimationFrame(reDraw); // Use requestAnimationFrame for smoother updates
    }
    e.preventDefault(); // Prevent scrolling while dragging
});

canvas.addEventListener('touchend', () => {
    selectedPoint = null;
});

// Event listeners for checkboxes
allCheckboxIds.forEach(id => {
    document.getElementById(id).addEventListener('change', () => {
        reDraw();
    });
});

// Event listener for unchecking all checkboxes
document.getElementById('uncheck-all-btn').addEventListener('click', () => {
    // Uncheck all checkboxes
    allCheckboxIds.forEach(id => {
        const checkbox = document.getElementById(id);
        if (checkbox) {
            checkbox.checked = false; // Set the checkbox to unchecked
        }
    });
    reDraw();
});

// Function to draw the original triangle
function drawOriginalTriangle() {
    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
    ctx.beginPath();
    ctx.strokeStyle = 'black'
    ctx.moveTo(points[0].x, points[0].y);
    ctx.lineTo(points[1].x, points[1].y);
    ctx.lineTo(points[2].x, points[2].y);
    ctx.closePath();
    ctx.stroke();

    // Draw vertices and labels
    points.forEach((point, index) => {
        drawPoint(point, ['A', 'B', 'C'][index]);
    });
}


// Draw centers or points based on checkbox states
function drawCenters() {
    Object.keys(centerStyles).forEach(key => {
        const style = centerStyles[key];
        const checkbox = document.getElementById(style.checkboxId);

        if (checkbox && checkbox.checked) {
            let centers = [];

            // Switch statement to handle different center calculations
            switch (key) {
                // case 'excenterA':
                //     centers.push(calculateExcenter([points[2], points[0], points[1]]));
                //     break;
                // case 'excenterB':
                //     centers.push(calculateExcenter(points));
                //     break;
                // case 'excenterC':
                //     centers.push(calculateExcenter([points[1], points[2], points[0]]));
                //     break;
                case 'excenters':
                    centers.push(...calculateExcenters(points));
                    break;
                case 'firstBrocardPoint':
                    centers.push(calculateBrocardPoint(points, 1));
                    break;
                case 'secondBrocardPoint':
                    centers.push(calculateBrocardPoint(points, 2));
                    break;
                case 'centroid':
                    centers.push(calculateCentroid(points));
                    break;
                case 'circumcenter':
                    centers.push(calculateCircumcenter(points));
                    break;
                case 'incenter':
                    centers.push(calculateIncenter(points));
                    break;
                case 'orthocenter':
                    centers.push(calculateOrthocenter(points));
                    break;
                case 'firstIsogonicCenter':
                    centers.push(calculateIsogonicCenter(points, true));
                    break;
                case 'FermatPoint':
                    centers.push(calculateFermatPoint(points));
                    break;
                case 'secondIsogonicCenter':
                    centers.push(calculateIsogonicCenter(points, false));
                    break;
                case 'firstIsodynamicPoint':
                    centers.push(calculateIsodynamicPoint(points, false));
                    break;
                case 'secondIsodynamicPoint':
                    centers.push(calculateIsodynamicPoint(points, true));
                    break;
                case 'ClawsonPoint':
                    centers.push(calculateClawsonPoint(points));
                    break;
                case 'deLongchampsPoint':
                    centers.push(calculateDeLongchampsPoint(points));
                    break;
                case 'SchifflerPoint':
                    centers.push(calculateSchifflerPoint(points));
                    break;
                case 'ExeterPoint':
                    centers.push(calculateExeterPoint(points));
                    break;
                case 'farOutPoint':
                    centers.push(calculateFarOutPoint(points));
                    break;
                case 'ninePointCenter':
                    centers.push(calculateNinePointCenter(points));
                    break;
                case 'firstNapoleonPoint':
                    centers.push(calculateNapoleonPoint(points, true));
                    break;
                case 'secondNapoleonPoint':
                    centers.push(calculateNapoleonPoint(points, false));
                    break;
                case 'symmedianPoint':
                    centers.push(calculateSymmedianPoint(points));
                    break;
                case 'GergonnePoint':
                    centers.push(calculateGergonnePoint(points));
                    break;
                case 'NagelPoint':
                    centers.push(calculateNagelPoint(points));
                    break;   
                case 'BrocardMidpoint':
                    centers.push(calculateBrocardMidpoint(points));
                    break;   
                case 'BevanPoint':
                    centers.push(calculateBevanPoint(points));
                    break;
                case 'KosnitaPoint':
                    centers.push(calculateKosnitaPoint(points));
                    break;
                case 'PrasolovPoint':
                    centers.push(calculatePrasolovPoint(points));
                    break;
                case 'thirdBrocardPoint':
                    centers.push(calculateBrocardPoint(points, 3));
                    break;
                case 'TarryPoint':
                    centers.push(calculateTarryPoint(points));
                    break;
                case 'SteinerPoint':
                    centers.push(calculateSteinerPoint(points));
                    break;
                case 'focusOfKiepertParabola':
                    centers.push(calculateFocusOfKiepertParabola(points));
                    break;
                case 'ParryPoint':
                    centers.push(calculateParryPoint(points));
                    break;
                case 'firstAjimaMalfattiPoint':
                    centers.push(calculateFirstAjimaMalfattiPoint(points));
                    break;
                case 'secondAjimaMalfattiPoint':
                    centers.push(calculateSecondAjimaMalfattiPoint(points));
                    break;
                case 'Mittenpunkt':
                    centers.push(calculateMittenpunkt(points));
                    break;
                case 'SpiekerCenter':
                    centers.push(calculateSpiekerCenter(points));
                    break;
                case 'FeuerbachPoint':
                    centers.push(calculateFeuerbachPoint(points));
                    break;
                case 'equalParalleliansPoint':
                    centers.push(calculateEqualParalleliansPoint(points));
                    break;   
                case 'FuhrmannCenter':
                    centers.push(calculateFuhrmannCenter(points));
                    break;
                case 'firstKenmotuPoint':
                    centers.push(calculateKenmotuPoint(points, true));
                    break;
                case 'secondKenmotuPoint':
                    centers.push(calculateKenmotuPoint(points, false));
                    break;
                case 'outerVectenPoint':
                    centers.push(calculateVectenPoint(points, true));
                    break;
                case 'innerVectenPoint':
                    centers.push(calculateVectenPoint(points, false));
                    break;
                case 'EvansPoint':
                    centers.push(calculateEvansPoint(points));
                    break;
                default:
                    console.error(`Unknown center key: ${key}`);
                    return;
            }
            // Draw
            centers.forEach(center => {
                if (center) {
                    drawPoint(center, style.annotationLabel, style.activeColor);
                }
            });
        }
    });
}

// Draw lines based on checkbox states
function drawLines() {
    Object.keys(lineStyles).forEach(key => {
        const style = lineStyles[key];
        const checkbox = document.getElementById(style.checkboxId);

        if (checkbox && checkbox.checked) {
            let lines = [];

            // Switch statement to handle different line calculations
            switch (key) {
                case 'sidelines':
                    lines.push(...calculateSidelines(points));
                    break;  
                case 'medians':
                    lines.push(...calculateMedians(points));
                    break;
                case 'perpendicularBisectors':
                    lines.push(...calculatePerpendicularBisectors(points));
                    break;                
                case 'internalAngleBisectors':
                    lines.push(...calculateInternalAngleBisectors(points));
                    break;
                case 'altitudes':
                    lines.push(...calculateAltitudes(points));
                    break;  
                case 'symmedians':
                    lines.push(...calculateSymmedians(points));
                    break;
                case 'exsymmedians':
                    lines.push(...calculateExsymmedians(points));
                    break;       
                case 'splitters':
                    lines.push(...calculateSplitters(points));
                    break;
                case 'cleavers':
                    lines.push(...calculateCleavers(points));
                    break;           
                case 'EulerLine':
                    lines.push(calculateEulerLine(points));
                    break;
                case 'GergonneLine':
                    lines.push(calculateGergonneLine(points));
                    break;
                case 'NagelLine':
                    lines.push(calculateNagelLine(points));
                    break;
                case 'vanAubelLine':
                    lines.push(calculateVanAubelLine(points));
                    break;
                case 'BrocardAxis':
                    lines.push(calculateBrocardAxis(points));
                    break;
                case 'FermatAxis':
                    lines.push(calculateFermatAxis(points));
                    break;
                case 'OrthicAxis':
                    lines.push(calculateOrthicAxis(points));
                    break;
                case 'OrthogonalRegressionLine':
                    lines.push(calculateOrthogonalRegressionLine(points));
                    break;
                default:
                    console.error(`Unknown line key: ${key}`);
                    return;
            }
            // Draw
            lines.forEach(line => {
                if (line) {
                    drawLine(line, style.annotationLabel, style.activeColor);
                }
            });

        }
    });
}

// Draw triangles based on checkbox states
function drawTriangles() {
    Object.keys(triangleStyles).forEach(key => {
        const style = triangleStyles[key];
        const checkbox = document.getElementById(style.checkboxId);
        
        if (checkbox && checkbox.checked) {
            let triangle;
            
            // Switch statement to handle different triangle calculations
            switch (key) {
                case 'medialTriangle':
                    triangle = calculateMedialTriangle(points);
                    break;
                case 'excentralTriangle':
                    triangle = calculateExcentralTriangle(points);
                    break;
                case 'orthicTriangle':
                    triangle = calculateOrthicTriangle(points);
                    break;
                case 'reflectionTriangle':
                    triangle = calculateReflectionTriangle(points);
                    break;
                case 'tangentialTriangle':
                    triangle = calculateTangentialTriangle(points);
                    break;
                case 'anticomplementaryTriangle':
                    triangle = calculateAnticomplementaryTriangle(points);
                    break;
                case 'circumMedialTriangle':
                    triangle = calculateCircumMedialTriangle(points);
                    break;
                case 'outerNapoleonTriangle':
                    triangle = calculateNapoleonTriangle(points, true);
                    break;
                case 'innerNapoleonTriangle':
                    triangle = calculateNapoleonTriangle(points, false);
                    break;
                case 'intouchTriangle':
                    triangle = calculateIntouchTriangle(points);
                    break;
                case 'extouchTriangle':
                    triangle = calculateExtouchTriangle(points);
                    break;
                case 'FuhrmannTriangle':
                    triangle = calculateFuhrmannTriangle(points);
                    break;
                case 'FeuerbachTriangle':
                    triangle = calculateFeuerbachTriangle(points);
                    break;
                case 'firstBrocardTriangle':
                    triangle = calculateBrocardTriangle(points, 1);
                    break;
                case 'secondBrocardTriangle':
                    triangle = calculateBrocardTriangle(points, 2);
                    break;
                case 'outerVectenTriangle':
                    triangle = calculateVectenTriangle(points, true);
                    break;
                case 'innerVectenTriangle':
                    triangle = calculateVectenTriangle(points, false);
                    break;
                case 'AymeTriangle':
                    triangle = calculateAymeTriangle(points);
                    break;
                case 'SteinerTriangle':
                    triangle = calculateSteinerTriangle(points);
                    break;
                default:
                    console.error(`Unknown triangle key: ${key}`);
                    return;
            }

            // Draw
            if (triangle) {
                drawPolygon(triangle, style.annotationLabel, style.activeColor);
            }
        }
    });
}

// Draw hexagons based on checkbox states
function drawHexagons() {
    Object.keys(hexagonStyles).forEach(key => {
        const style = hexagonStyles[key];
        const checkbox = document.getElementById(style.checkboxId);
        
        if (checkbox && checkbox.checked) {
            let hexagon;
            
            switch (key) {
                case 'firstLemoineHexagon':
                    hexagon = calculateLemoineHexagon(points, true);
                    break;
                case 'secondLemoineHexagon':
                    hexagon = calculateLemoineHexagon(points, false);
                    break;
                default:
                    console.error(`Unknown hexagon key: ${key}`);
                    return;
            }

            // Draw
            if (hexagon) {
                drawPolygon(hexagon, style.annotationLabel, style.activeColor);
            }
        }
    });
}


// Draw parabolas based on checkbox states
function drawParabolas() {
    Object.keys(parabolaStyles).forEach(key => {
        const style = parabolaStyles[key];
        const checkbox = document.getElementById(style.checkboxId);
        
        if (checkbox && checkbox.checked) {
            let parabolas = [];
            
            switch (key) {
                case 'KiepertParabola':
                    parabolas.push(calculateKiepertParabola(points)); // Add a single circle to the list
                    break;
                default:
                    console.error(`Unknown parabola key: ${key}`);
                    return;
            }

            // Draw
            parabolas.forEach(parabola => {
                if (parabola) {
                    drawParabola(parabola, style.annotationLabel, style.activeColor);
                }
            });
        }
    });
}

// Draw circles based on checkbox states
function drawCircles() {
    Object.keys(circleStyles).forEach(key => {
        const style = circleStyles[key];
        const checkbox = document.getElementById(style.checkboxId);

        if (checkbox && checkbox.checked) {
            let circles = []; // Multiple circles can be stored here

            // Switch statement to handle different circle calculations
            switch (key) {
                case 'incircle':
                    circles.push(calculateIncircle(points)); // Add a single circle to the list
                    break;
                case 'circumcircle':
                    circles.push(calculateCircumcircle(points));
                    break;
                // case 'excircleA':
                //     circles.push(calculateExcircle([points[2], points[0], points[1]]));
                //     break;
                // case 'excircleB':
                //     circles.push(calculateExcircle(points));
                //     break;
                // case 'excircleC':
                //     circles.push(calculateExcircle([points[1], points[2], points[0]]));
                //     break;
                case 'excircles':
                    circles.push(...calculateExcircles(points));
                    break;
                case 'ninePointCircle':
                    circles.push(calculateNinePointCircle(points));
                    break;
                case 'orthocentroidalCircle':
                    circles.push(calculateOrthocentroidalCircle(points));
                    break;
                case 'smallestCircle':
                    circles.push(calculateSmallestCircle(points));
                    break;
                case 'LesterCircle':
                    circles.push(calculateLesterCircle(points));
                    break;
                case 'BevanCircle':
                    circles.push(calculateBevanCircle(points));
                    break;
                case 'SpiekerCircle':
                    circles.push(calculateSpiekerCircle(points));
                    break;
                case 'AdamsCircle':
                    circles.push(calculateAdamsCircle(points));
                    break;
                case 'FuhrmannCircle':
                    circles.push(calculateFuhrmannCircle(points));
                    break;
                case 'MandartCircle':
                    circles.push(calculateMandartCircle(points));
                    break;
                case 'MalfattiCircles':
                    circles.push(...calculateMalfattiCircles(points));
                    break;
                case 'ParryCircle':
                    circles.push(calculateParryCircle(points));
                    break;
                case 'BrocardCircle':
                    circles.push(calculateBrocardCircle(points));
                    break;
                case 'TaylorCircle':
                    circles.push(calculateTaylorCircle(points));
                    break;
                case 'VanLamoenCircle':
                    circles.push(calculateVanLamoenCircle(points));
                    break;
                case 'firstLemoineCircle':
                    circles.push(calculateFirstLemoineCircle(points));
                    break;
                case 'cosineCircle':
                    circles.push(calculateCosineCircle(points));
                    break;
                case 'KenmotuCircle':
                    circles.push(calculateKenmotuCircle(points));
                    break;
                case 'ConwayCircle':
                    circles.push(calculateConwayCircle(points));
                    break;
                case 'mixtilinearIncircles':
                    circles.push(...calculateMixtilinearIncircles(points));
                    break;
                case 'threeExternallyTangentCircles':
                    circles.push(...calculateThreeExternallyTangentCircles(points));
                    break;
                default:
                    console.error(`Unknown circle key: ${key}`);
                    return;
            }

            // Draw
            circles.forEach(circle => {
                if (circle) {
                    drawCircle(circle, style.annotationLabel, style.activeColor);
                }
            });
        }
    });
}

// Draw ellipses based on checkbox states
function drawEllipses() {
    Object.keys(ellipseStyles).forEach(key => {
        const style = ellipseStyles[key];
        const checkbox = document.getElementById(style.checkboxId);
        
        if (checkbox && checkbox.checked) {
            let ellipse;
            
            switch (key) {
                case 'SteinerInellipse':
                    ellipse = calculateSteinerInellipse(points);
                    break;
                case 'SteinerCircumellipse':
                    ellipse = calculateSteinerCircumellipse(points);
                    break;
                case 'LemoineInellipse':
                    ellipse = calculateLemoineInellipse(points);
                    break;
                default:
                    console.error(`Unknown ellipse key: ${key}`);
                    return;
            }

            // Draw
            if (ellipse) {
                drawEllipse(ellipse, style.annotationLabel, style.activeColor);
            }
        }
    });
}

// Function to draw a point and its label
function drawPoint(point, label = '', color = 'black') {
    ctx.beginPath();
    ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    
    // Draw the label near the point
    if (label){
        ctx.font = '16px Arial';
        ctx.fillStyle = color;
        ctx.fillText(label, point.x - 5, point.y + 20); // Adjust position for readability
    }
}

// Function to draw a line between two points within the canvas bounds
function drawLine(line, label = '', color = 'black') {
    const [point1, point2] = line;
    if (closeEnoughPoints(point1, point2)) {
        return null;
    }
    const slope = calculateSlope(point1, point2);

    // Function to calculate y for a given x using the equation y = slope * x + b
    function calculateY(x) {
        if (isFinite(slope)) {
            return slope * (x - point1.x) + point1.y;
        } else {
            return null; // Vertical line, no y value for a given x
        }
    }

    // Function to calculate x for a given y using the equation x = (y - b) / slope
    function calculateX(y) {
        if (isFinite(slope)) {
            return (y - point1.y) / slope + point1.x;
        } else {
            return point1.x; // Vertical line, x is constant
        }
    }

    // Find the intersection points of the line with the canvas bounds
    let points = [];

    // When the line is vertical
    if (!isFinite(slope)) {
        if (0 <= point1.x && point1.x <= CANVAS_WIDTH) {
            points.push({ x: point1.x, y: 0 });
            points.push({ x: point1.x, y: CANVAS_HEIGHT });
        }
    } else {
        // Check for intersection with the left (x = 0) and right (x = CANVAS_WIDTH) boundaries
        let yAtX0 = calculateY(0);
        if (0 <= yAtX0 && yAtX0 <= CANVAS_HEIGHT) {
            points.push({ x: 0, y: yAtX0 });
        }
        let yAtXMax = calculateY(CANVAS_WIDTH);
        if (0 <= yAtXMax && yAtXMax <= CANVAS_HEIGHT) {
            points.push({ x: CANVAS_WIDTH, y: yAtXMax });
        }

        // Check for intersection with the top (y = 0) and bottom (y = CANVAS_HEIGHT) boundaries
        let xAtY0 = calculateX(0);
        if (0 < xAtY0 && xAtY0 < CANVAS_WIDTH) {
            points.push({ x: xAtY0, y: 0 });
        }
        let xAtYMax = calculateX(CANVAS_HEIGHT);
        if (0 < xAtYMax && xAtYMax < CANVAS_WIDTH) {
            points.push({ x: xAtYMax, y: CANVAS_HEIGHT });
        }
    }


    // If we have exactly two points, draw the line segment
    if (points.length === 2) {
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        ctx.lineTo(points[1].x, points[1].y);
        ctx.strokeStyle = color;
        ctx.stroke();

        // Draw the label near the midpoint of the line
        if (label) {
            const midX = (points[0].x + points[1].x) / 2;
            const midY = (points[0].y + points[1].y) / 2;
            ctx.font = '16px Arial';
            ctx.fillStyle = color;
            ctx.fillText(label, midX - 5, midY - 10); // Adjust position for readability
        }
    }
}

// Function to draw a polygon
function drawPolygon(polygon, label = '', color = 'black') {
    if (polygon.length < 3) {
        console.error("A polygon must have at least 3 vertices.");
        return;
    }

    // Draw the polygon
    ctx.beginPath();
    ctx.moveTo(polygon[0].x, polygon[0].y);
    for (let i = 1; i < polygon.length; i++) {
        ctx.lineTo(polygon[i].x, polygon[i].y);
    }
    ctx.closePath();
    ctx.strokeStyle = color;
    ctx.stroke();

    // Draw the label at the centroid of the polygon
    if (label) {
        // Calculate the centroid of the polygon
        let centroidX = 0, centroidY = 0;
        polygon.forEach(point => {
            centroidX += point.x;
            centroidY += point.y;
        });
        centroidX /= polygon.length;
        centroidY /= polygon.length;

        ctx.fillStyle = color;
        ctx.fillText(label, centroidX, centroidY);
    }
}


/*
Draws a parabola on the canvas.
The parabola can be transformed with translation and rotation.
@param {CanvasRenderingContext2D} ctx - The rendering context for the canvas.
@param {number} x - The x-axis (horizontal) coordinate of the parabola's focus.
@param {number} y - The y-axis (vertical) coordinate of the parabola's focus.
@param {number} a - The focal length of the parabola, where the focus is located at (0, a) and the directrix at y = -a before any transformations. 
@param {number} rotation - The angle of rotation around the focus, in radians.
@param {number} startPos - Optional. Default is 0. The initial x-coordinate for defining the portion of the parabola to draw, before any transformations are applied.
                           After transformations, this corresponds to a distance along the directrix.
                           The value 0 represents the point where the line perpendicular to the directrix, passing through the focus, intersects the directrix. 
@param {number} endPos - Optional. Default is 0. The final x-coordinate for defining the portion of the parabola to draw, before any transformations. 
                         If startPos equals endPos, the range will be calculated automatically to fit the canvas.
@param {boolean} counterclockwise - Optional. Default is false. If true, the parabola is drawn counterclockwise; otherwise, it is drawn clockwise. 
*/

function _drawParabola(ctx, x, y, a, rotation, startPos = 0, endPos = 0, counterclockwise = false, color = '#000000') {
    
    // Function to calculate the y-coordinate of the parabola on the x-coordinate.
    function parabola(x) {
        return x * x / 4 / a;
    }

    // Function to calculate an intersection of two tangent lines of points on the parabola.
    function intersectionOfTangentLines(point1, point2, a) {
        const x1 = point1.x;
        const y1 = point1.y;
        const x2 = point2.x;
        const y2 = point2.y;
        const x = x1 + x2 + 2 * a * (y2 - y1) / (x1 - x2);
        return {
            x: x,
            y: y1 + x1 * (x - x1) / 2 / a
        };
    }
    
    // Function to translate a point.
    function translate(point, deltaX, deltaY) {
        return {x: point.x + deltaX, y: point.y + deltaY};
    }
    
    // Function to rotate a point around the center, expressed in radians.
    function rotate(point, center, radian) {
        const deltaX = point.x - center.x;
        const deltaY = point.y - center.y;
        return {
            x: center.x + (deltaX * Math.cos(radian) - deltaY * Math.sin(radian)),
            y: center.y + (deltaX * Math.sin(radian) + deltaY * Math.cos(radian))
        };
    }

    // Function to calculate intersections of the parabola and line.
    // a: The focal length of the parabola, where the focus is located at (0, a) and the directrix at y = -a.
    // point1: A point passes through the line.
    // point2: Another point passes through the line. 
    function intersectionOfParabolaAndLine(a, point1, point2, epsilon = 0.001) {
        let intersections = [];
        const x1 = point1.x;
        const y1 = point1.y;
        const x2 = point2.x;
        const y2 = point2.y;
        if (Math.abs(x1-x2) < epsilon) {  // When the line is vertical.
            intersections.push({x: x1, y: parabola(x1)});
        }
        else {
            const slope = (y2 - y1) / (x2 - x1);
            const intercept = y1 - slope * x1;
            const discriminant = 4 * a * (a * slope **2 + intercept);
            if (discriminant > 0) {
                const xa = 2 * a * slope + Math.sqrt(discriminant);
                const xb = 2 * a * slope - Math.sqrt(discriminant);
                intersections.push({x: xa, y: parabola(xa)});
                intersections.push({x: xb, y: parabola(xb)});
            }
            else if (discriminant == 0){
                const xa = 2 * a * slope;
                intersections.push({x: xa, y: parabola(xa)});
            }
        }
        return intersections;
    }

    // Function to calculate the cross product of vectors p1p2 and p1p3.
    function crossProduct(point1, point2, point3) {
        return (point2.x - point1.x) * (point3.y - point1.y)
             - (point2.y - point1.y) * (point3.x - point1.x);
    }

    // Filter the points in the rectangle whose corners are corner1, corner2, corner3 and corner4 (defined in cyclically order)
    function filterInRectangle(intersections, corner1, corner2, corner3, corner4, epsilon = 0.001) {
        return intersections.filter(point => {
            // Calculate the cross product for each edge and the point
            const cross1 = crossProduct(corner1, corner2, point);
            const cross2 = crossProduct(corner2, corner3, point);
            const cross3 = crossProduct(corner3, corner4, point);
            const cross4 = crossProduct(corner4, corner1, point);

            // Check if all cross products are non-negative or non-positive (on the same side of all edges)
            return (cross1 >= - epsilon && cross2 >= - epsilon && cross3 >= - epsilon && cross4 >= - epsilon) ||
                   (cross1 <= epsilon && cross2 <= epsilon && cross3 <= epsilon && cross4 <= epsilon);
        });
    }

    // Draw parabola using quadratic Bezier curve.
    // Note that the Bezier curve is affine invariant, meaning that an affine transformation of its control points produces 
    // the same result as constructing the curve first and then applying the transformation.
    const focus = {x: 0, y: a};  // Focus of the parabola before any transformations.
    // Start point (1st control point), control point (2nd control point) and end point (3rd control point) of the quadratic Bezier curve before any transformations.
    let startPoint, controlPoint, endPoint;
    let rotatedStartPoint, rotatedControlPoint, rotatedEndPoint;  // Rotated points.
    let translatedStartPoint, translatedControlPoint, translatedEndPoint;  // Rotated and translated points.
    const radian = counterclockwise ? -rotation : rotation; // Radian for rotation.
    const deltaX = x;  // Delta x for translation.
    const deltaY = y - a;  // Delta y for translation.
    const epsilon = 0.001;  // A small value to account for calculation errors.

    if (startPos == endPos) {  // When the drawing range is automatically calculated to fall within the canvas.
        // Calculate the intersections of frame lines and parabola.
        const width = ctx.canvas.width; // Canvas width.
        const height = ctx.canvas.height; // Canvas height.
        // Corners of the canvas frame after transformations of the parabola.
        const topLeftCorner     = {x:     0, y:      0};
        const topRightCorner    = {x: width, y:      0};
        const bottomLeftCorner  = {x:     0, y: height};
        const bottomRightCorner = {x: width, y: height};
        
        // Corners of the canvas frame before any transformations of the parabola.
        const transformedTopLeftCorner     = rotate(translate(    topLeftCorner, - deltaX, - deltaY), focus, - radian);
        const transformedTopRightCorner    = rotate(translate(   topRightCorner, - deltaX, - deltaY), focus, - radian);
        const transformedBottomLeftCorner  = rotate(translate( bottomLeftCorner, - deltaX, - deltaY), focus, - radian);
        const transformedBottomRightCorner = rotate(translate(bottomRightCorner, - deltaX, - deltaY), focus, - radian);

        // Intersections of the parabola and transformed frame lines before any transformations of the parabola.
        let intersections = [];
        intersections.push(...intersectionOfParabolaAndLine(a,    transformedTopLeftCorner,    transformedTopRightCorner, epsilon));
        intersections.push(...intersectionOfParabolaAndLine(a, transformedBottomLeftCorner, transformedBottomRightCorner, epsilon));
        intersections.push(...intersectionOfParabolaAndLine(a,    transformedTopLeftCorner,  transformedBottomLeftCorner, epsilon));
        intersections.push(...intersectionOfParabolaAndLine(a,   transformedTopRightCorner, transformedBottomRightCorner, epsilon));

        // Select the points in the rectangle constructed from the frame lines.
        intersections = filterInRectangle(intersections, transformedTopLeftCorner, transformedTopRightCorner,
                                          transformedBottomRightCorner, transformedBottomLeftCorner, epsilon);
        // The startPoint is the point with the smallest x-coordinate (leftmost point).
        startPoint = intersections.reduce((min, point) => {
            return point.x < min.x ? point : min;
        });
        // The endPoint is the point with the largest x-coordinate (rightmost point).
        endPoint = intersections.reduce((max, point) => {
            return point.x > max.x ? point : max;
        });
    }
    else {  // When the drawing range is specified as parameters.
        startPoint = {x: startPos, y: parabola(startPos)};  
        endPoint =   {x: endPos,   y: parabola(endPos)};
    }
    // The second control point of a quadratic Bezier curve is the intersection of the tangents to the first and third control points.
    controlPoint = intersectionOfTangentLines(startPoint, endPoint, a);

    // Rotate control points.
    rotatedStartPoint   = rotate(startPoint,   focus, radian);
    rotatedControlPoint = rotate(controlPoint, focus, radian);
    rotatedEndPoint     = rotate(endPoint,     focus, radian);

    // Translate control points.
    translatedStartPoint   = translate(rotatedStartPoint,   deltaX, deltaY);
    translatedControlPoint = translate(rotatedControlPoint, deltaX, deltaY);
    translatedEndPoint     = translate(rotatedEndPoint,     deltaX, deltaY);

    // Draw the parabola using quadratic Bezier curve.
    // The first and third control points are the endpoints of the Bezier curve, as well as the endpoints of the segment of the parabola.
    ctx.beginPath();
    ctx.moveTo(translatedStartPoint.x, translatedStartPoint.y);
    ctx.quadraticCurveTo(translatedControlPoint.x, translatedControlPoint.y, 
                         translatedEndPoint.x, translatedEndPoint.y);
    ctx.strokeStyle = color;
    ctx.stroke();
}

/*
Function to draw a parabola
Parabola data structure
const parabola = {
    focus: {x: ???, y: ???},  // Focus of the parabola
    directrix: [{x: ???, y: ???}, {x: ???, y: ???}],  // Two points pass through the directrix of the parabola
};
*/
function drawParabola(parabola, label = '', color = 'black') {
    const a = calculateDistanceToLine(parabola.focus, parabola.directrix) / 2;
    const slope = calculateSlope(...parabola.directrix);
    const intercept = parabola.directrix[0].y - slope * parabola.directrix[0].x;
    let rotation = calculateAngleInRadianWithXAxis(parabola.directrix);
    if (Math.abs(rotation) > Math.PI / 2) {
        rotation = rotation > 0 ? rotation - Math.PI : rotation + Math.PI;
    }
    if (slope * parabola.focus.x + intercept > parabola.focus.y) {
        rotation += Math.PI;
    }
    console.log(rotation);
    _drawParabola(ctx, parabola.focus.x, parabola.focus.y, a, rotation, 0, 0, false, color);

    if (label){
        ctx.fillStyle = color;
        ctx.fillText(label, parabola.focus.x, parabola.focus.y);
    }
}

// Function to draw a circle
function drawCircle(circle, label = '', color = 'black') {
    ctx.beginPath();
    ctx.arc(circle.center.x, circle.center.y, circle.radius, 0, Math.PI * 2); // Draw a full circle
    ctx.strokeStyle = color;
    ctx.stroke();
    if (label){
        ctx.fillStyle = color;
        ctx.fillText(label, circle.center.x, circle.center.y + circle.radius + 15);
    }
}

/*
Function to draw an ellipse
Ellipse data structure
const ellipse = {
    center: { x: ???, y: ??? },  // Center of the ellipse
    radiusX: ???,                // Length of semi-major axis (half of the major axis)
    radiusY: ???,                // Length of semi-minor axis (half of the minor axis)
    rotationRadian: ???          // Rotation angle in radians
};
*/
// Function to draw an ellipse
function drawEllipse(ellipse, label = '', color = 'black') {
    const { center, radiusX, radiusY, rotationRadian } = ellipse;

    // Begin drawing the ellipse
    ctx.beginPath();
    
    // Use CanvasRenderingContext2D's `ellipse` method to draw the ellipse
    // ctx.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle)
    ctx.ellipse(center.x, center.y, radiusX, radiusY, rotationRadian, 0, 2 * Math.PI);

    // Set the stroke style and draw the outline of the ellipse
    ctx.strokeStyle = color;
    ctx.stroke();

    // Draw the label at the center of the ellipse
    if (label) {
        ctx.fillStyle = color;
        ctx.fillText(label, center.x, center.y);
    }
}


// Function to calculate the distance between two points
function calculateDistance(p1, p2) {
    return Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
}

function vectorSubtract(p1, p2) {
    return { x: p1.x - p2.x, y: p1.y - p2.y };
}

function calculateDotProduct(v1, v2) {
    return v1.x * v2.x + v1.y * v2.y;
}

// Cross product of vectors p1p2 and p1p3
function calculateCrossProduct(p1, p2, p3) {
    return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);
}

function magnitude(v) {
    return Math.sqrt(v.x * v.x + v.y * v.y);
}

// Function to calculate the cosine value of the angle at the middle point (B) given three points A, B, and C.
function calculateCosine(p1, p2, p3) {
    const v21 = vectorSubtract(p1, p2);
    const v23 = vectorSubtract(p3, p2);
    return calculateDotProduct(v21, v23) / (magnitude(v21) * (magnitude(v23)));
}

// Function to calculate the sine value of the angle at the middle point (B) given three points A, B, and C.
function calculateSine(p1, p2, p3) {
    const v21 = vectorSubtract(p1, p2);
    const v23 = vectorSubtract(p3, p2);
    const crossProductMagnitude = Math.abs(v21.x * v23.y - v21.y * v23.x);
    return crossProductMagnitude / (magnitude(v21) * magnitude(v23));
}

// Function to calculate the angle (radian) at the middle point (B) given three points A, B, and C.
function calculateAngleInRadians(p1, p2, p3) {
    return Math.acos(calculateCosine(p1, p2, p3));
}

// Function to calculate the angle (degree) at the middle point (B) given three points A, B, and C.
function calculateAngleInDegrees(p1, p2, p3) {
    const thetaRad = calculateAngleInRadians(p1, p2, p3);
    return thetaRad * (180 / Math.PI);
}

// Function to calculate the semiperimeter of the triangle
function calculateSemiperimeter(points) {
    const [A, B, C] = points;
    const a = calculateDistance(B, C);
    const b = calculateDistance(A, C);
    const c = calculateDistance(A, B);
    return (a + b + c) / 2;
}

// Function to calculate the area of the triangle
function calculateArea(points) {
    const [A, B, C] = points;
    return Math.abs((A.x * (B.y - C.y) + B.x * (C.y - A.y) + C.x * (A.y - B.y))) / 2;
}

function calculateSlope(p1, p2) {
    return (p2.y - p1.y) / (p2.x - p1.x)
}

function midpoint(p1, p2){
    return {
        x: (p1.x + p2.x) / 2,
        y: (p1.y + p2.y) / 2
    }
}

function closeEnoughScalars(val1, val2) {
    return Math.abs(val1 - val2) < epsilon;
}

function closeEnoughPoints(p1, p2) {
    return calculateDistance(p1, p2) < epsilon;
}

function closeEnoughCircles(c1, c2) {
    return closeEnoughPoints(c1.center, c2.center) && closeEnoughScalars(c1.radius, c2.radius);
}

// Check if the points ()= [A, B, C]) is counterclockwise or not
function isCounterclockwiseOrder(points) {
    const [A, B, C] = points;
    return calculateCrossProduct(A, B, C) > 0 ? false : true;
}

// Check if a triangle is equilateral
function isEquilateralTriangle(points) {
    const [A, B, C] = points;
    // Calculate the lengths of the sides of the triangle
    const a = calculateDistance(B, C); // Length of side BC
    const b = calculateDistance(A, C); // Length of side CA
    const c = calculateDistance(A, B); // Length of side AB
    
    // Check if all sides are approximately equal
    return closeEnoughScalars(a, b) && closeEnoughScalars(b, c);
}

// Check if a triangle is scalene
function isScaleneTriangle(points) {
    const [A, B, C] = points;
    const a = calculateDistance(B, C);
    const b = calculateDistance(C, A);
    const c = calculateDistance(A, B);
    return !closeEnoughScalars(a, b) && !closeEnoughScalars(b, c) && !closeEnoughScalars(c, a);
}

// Check if a triangle is a right triangle
function isRightTriangle(points) {
    const [A, B, C] = points;
    const a = calculateDistance(B, C);
    const b = calculateDistance(C, A);
    const c = calculateDistance(A, B);

    // Sort sides so that a <= b <= c
    const sides = [a, b, c].sort((x, y) => x - y);

    // Check if the triangle satisfies the Pythagorean theorem
    return closeEnoughScalars(sides[0] ** 2 + sides[1] ** 2, sides[2] ** 2);
}

function perpendicularSlope(slope) {
    // Handle cases where slopes might be 0 or undefined (vertical or horizontal lines)
    if (slope === 0) {
        return Infinity; // slope is horizontal, perpendicular is vertical
    } else if (!isFinite(slope)) {
        return 0; // slope is vertical, perpendicular is horizontal
    } else {
        return -1 / slope;
    }
}

// Function to rotate a point P around another point O by d degrees
// Be careful to consider the coordinates in canvas environment
function rotate(P, O, d) {
    const radian = Math.PI*d / 180;
    const dx = P.x - O.x;
    const dy = P.y - O.y;
    return {
        x: O.x + (dx * Math.cos(radian) - dy * Math.sin(radian)),
        y: O.y + (dx * Math.sin(radian) + dy * Math.cos(radian))
    };
}

// Function to calculate the distance from a point to a line defined by two points
function calculateDistanceToLine(point, line) {
    const [p1, p2] = line;

    // Check if the line is vertical
    if (p1.x === p2.x) {
        // Vertical line case: distance is the horizontal difference
        return Math.abs(point.x - p1.x);
    } else {
        // Calculate the slope and intercept of the line
        const slope = calculateSlope(p1, p2);
        const intercept = p1.y - slope * p1.x;

        // Distance formula for point (x0, y0) to line y = mx + b
        return Math.abs(slope * point.x - point.y + intercept) / Math.sqrt(slope * slope + 1);
    }
}


/**
 * Function to reflect a point across a line segment.
 * Parameters;
 * point - The point to reflect, with properties x and y.
 * linePoints - An array of two points, each with properties x and y, representing the line segment.
 * Returns;
 * The reflected point with properties x and y.
 */
 function reflectPointAcrossLine(point, line) {
    const [p1, p2] = line;
    const slope = calculateSlope(p1, p2);

    // If the line is vertical
    if (!isFinite(slope)) {
        return {
            x: 2 * p1.x - point.x,
            y: point.y
        };
    }

    // If the line is horizontal
    if (slope === 0) {
        return {
            x: point.x,
            y: 2 * p1.y - point.y
        };
    }

    const intercept = p1.y - slope * p1.x;
    const perSlope = perpendicularSlope(slope);
    
    // Calculate the intersection of the line through the point and perpendicular to the given line
    const intersection = lineIntersectionGivenSlopesAndPoints(slope, p1, perSlope, point);
    return {
        x: 2 * intersection.x - point.x,
        y: 2 * intersection.y - point.y
    };
}

function reflectPointAcrossCenter(point, center) {
    return {x: 2*center.x-point.x, y:2*center.y-point.y};
}

function SlopeAndPointToLine(slope, point) {
    const deltaX = 10;
    let point1, point2;

    if (!isFinite(slope)) {
        // vertical line
        point1 = point;
        point2 = { x: point.x, y: point.y + deltaX };
    } else if (slope === 0) {
        // horizontal line
        point1 = point;
        point2 = { x: point.x + deltaX, y: point.y };
    } else {
        point1 = point;
        point2 = { x: point.x + deltaX, y: point.y + slope * deltaX };
    }

    return [point1, point2];
}


// Function to find the intersection of two lines (P1, P2) and (Q1, Q2)
function lineIntersection(P1, P2, Q1, Q2) {
    const a1 = P2.y - P1.y;
    const b1 = P1.x - P2.x;
    const c1 = a1 * P1.x + b1 * P1.y;

    const a2 = Q2.y - Q1.y;
    const b2 = Q1.x - Q2.x;
    const c2 = a2 * Q1.x + b2 * Q1.y;

    const determinant = a1 * b2 - a2 * b1;

    if (determinant === 0) {
        return null; // Parallel lines
    } else {
        const x = (b2 * c1 - b1 * c2) / determinant;
        const y = (a1 * c2 - a2 * c1) / determinant;
        return { x, y };
    }
}

/**
 * This function calculates the intersection point of two lines, given their slopes and a point on each line.
 * The equations of the lines are derived using the point-slope form of a line equation: 
 * (y - y1) = m(x - x1), where m is the slope and (x1, y1) is a point on the line.
 * 
 * Parameters:
 *  - slope1: The slope of the first line.
 *  - point1: An object representing a point {x, y} on the first line.
 *  - slope2: The slope of the second line.
 *  - point2: An object representing a point {x, y} on the second line.
 * 
 * Returns:
 *  - An object {x, y} representing the intersection point of the two lines.
 *  - If the lines are parallel (i.e., the slopes are the same), the function returns null.
 */
 function lineIntersectionGivenSlopesAndPoints(slope1, point1, slope2, point2) {
    // Check if the lines are parallel by comparing the slopes
    if (slope1 === slope2) {
        return null; // Parallel lines do not intersect
    } else if (!isFinite(slope1)) {
        // If the line1 is vertical
        const x = point1.x;
        const y = slope2 * (x - point2.x) + point2.y;
        return { x, y };
    } else if (!isFinite(slope2)) {
        // If the line2 is vertical
        const x = point2.x;
        const y = slope1 * (x - point1.x) + point1.y;
        return { x, y };
    } else {
        // Calculate the intersection point using the point-slope formula
        const x = (slope1 * point1.x - point1.y - slope2 * point2.x + point2.y) / (slope1 - slope2);
        const y = slope1 * (x - point1.x) + point1.y;
        return { x, y };
    }
}


// Function to calculate a tangency point between two circles
function calculateTangencyPoint(c1, c2) {
    if (closeEnoughCircles(c1, c2)) {
        return null;
    }
    slope = calculateSlope(c1.center, c2.center);
    let P1, P2;
    if (isFinite(slope)) {
        const coefficient = c1.radius / Math.sqrt(slope ** 2 + 1);
        P1 = {
            x: c1.center.x + coefficient,
            y: c1.center.y + slope * coefficient
        };
        P2 = {
            x: c1.center.x - coefficient,
            y: c1.center.y - slope * coefficient
        };
    }
    else{
        P1 = {
            x: c1.center.x,
            y: c1.center.y + c1.radius
        };
        P2 = {
            x: c1.center.x,
            y: c1.center.y - c1.radius
        };
    }
    if (closeEnoughScalars((P1.x - c2.center.x)**2 + (P1.y - c2.center.y)**2, c2.radius ** 2)) {
        return P1;
    }
    else {
        return P2;
    }
}


// Function to calculate the circle passing through points B, C and tangent to line AC at C
function calculateCircleTangentToLine(C, B, A){
    // Calculate the slope of the line perpendicular to AC at point C (normal to AC at C)
    const perpendicularSlope = -1 / calculateSlope(A, C);
    const tempConst = B.y - C.y;
    if (!isFinite(perpendicularSlope)) {
        const center = {
            x: C.x,
            y: ((C.x - B.x)**2 + B.y**2 - C.y**2) / 2 / tempConst
        };
        return {
            center: center,
            radius: calculateDistance(C, center)
        };
    }
    else {
        const x = (B.x **2 - C.x**2 + tempConst **2 + 2 * perpendicularSlope * C.x * tempConst) / 2 / (B.x - C.x + perpendicularSlope * tempConst);
        const y = perpendicularSlope * (x - C.x) + C.y;
        const center = {x, y};
        return {
            center: center,
            radius: calculateDistance(center, B)
        };
    }
}

function calculateIntersectionOfCircleAndLine(circle, line) {
    const {radius, center} = circle;
    const [point1, point2] = line;
    
    const x1 = point1.x
    const y1 = point1.y;
    const x2 = point2.x
    const y2 = point2.y;
    const h = center.x;
    const k = center.y;
    const r = radius;

    let intersections = [];

    if (x1 === x2) { // Vertical line (infinite slope)
        // x = x1, solve (x - h)^2 + (y - k)^2 = r^2
        const x = x1;
        const A = 1;
        const B = -2 * k;
        const C = (x1 - h) * (x1 - h) + k * k - r * r;
        const discriminant = B * B - 4 * A * C;

        if (discriminant < 0) return intersections; // No intersection

        const yPos = (-B + Math.sqrt(discriminant)) / (2 * A);
        const yNeg = (-B - Math.sqrt(discriminant)) / (2 * A);

        intersections.push({ x: x1, y: yPos });
        if (discriminant > 0) intersections.push({ x: x1, y: yNeg });

    } else if (y1 === y2) { // Horizontal line
        // y = y1, solve (x - h)^2 + (y - k)^2 = r^2
        const y = y1;
        const A = 1;
        const B = -2 * h;
        const C = (y1 - k) * (y1 - k) + h * h - r * r;
        const discriminant = B * B - 4 * A * C;

        if (discriminant < 0) return intersections; // No intersection

        const xPos = (-B + Math.sqrt(discriminant)) / (2 * A);
        const xNeg = (-B - Math.sqrt(discriminant)) / (2 * A);

        intersections.push({ x: xPos, y: y1 });
        if (discriminant > 0) intersections.push({ x: xNeg, y: y1 });

    } else { // Finite slope line
        // Parametrize the line as y = mx + c
        const m = (y2 - y1) / (x2 - x1);
        const c = y1 - m * x1;

        // Solve (x - h)^2 + (y - k)^2 = r^2 with y = mx + c
        const A = 1 + m * m;
        const B = 2 * (m * (c - k) - h);
        const C = h * h + (c - k) * (c - k) - r * r;
        const discriminant = B * B - 4 * A * C;

        if (discriminant < 0) return intersections; // No intersection

        const xPos = (-B + Math.sqrt(discriminant)) / (2 * A);
        const xNeg = (-B - Math.sqrt(discriminant)) / (2 * A);
        const yPos = m * xPos + c;
        const yNeg = m * xNeg + c;

        intersections.push({ x: xPos, y: yPos });
        if (discriminant > 0) intersections.push({ x: xNeg, y: yNeg });
    }

    return intersections;
}

function calculateIntersectionOfTwoCircles(circleA, circleB) {
    const cA = circleA.center;
    const rA = circleA.radius;
    const cB = circleB.center;
    const rB = circleB.radius;

    const d = Math.sqrt((cB.x - cA.x)**2 + (cB.y - cA.y)**2);

    // Check if the circles intersect
    if (d > rA + rB || d < Math.abs(rA - rB) || d === 0) {
        // No intersection, or circles are identical
        return null;
    }

    // a is the distance from cA to the point where the line through the circle intersections crosses the radical axis
    const a = (rA**2 - rB**2 + d**2) / (2 * d);

    // h is the distance from the point to the intersection points
    const h = Math.sqrt(rA**2 - a**2);

    // Point P is the point where the line through the intersections crosses the radical axis
    const P = {
        x: cA.x + a * (cB.x - cA.x) / d,
        y: cA.y + a * (cB.y - cA.y) / d
    };

    // The two intersection points

    // P + unit vector from cA to cB rotated by -π/2 to find the first intersection point
    const intersection1 = {
        x: P.x + h * (cB.y - cA.y) / d,
        y: P.y - h * (cB.x - cA.x) / d
    };

    // P + unit vector from cA to cB rotated by π/2 to find the first intersection point
    const intersection2 = {
        x: P.x - h * (cB.y - cA.y) / d,
        y: P.y + h * (cB.x - cA.x) / d
    };

    return [intersection1, intersection2];
}



function calculateIntersectionOfThreeCircles(circleA, circleB, circleC){
    const [p1, p2] = calculateIntersectionOfTwoCircles(circleA, circleB);
    const cC = circleC.center;
    const rC = circleC.radius;
    const error1 = Math.abs(rC**2 - (p1.x - cC.x)**2 - (p1.y - cC.y)**2);
    const error2 = Math.abs(rC**2 - (p2.x - cC.x)**2 - (p2.y - cC.y)**2);
    if (error1 < error2) {
        return p1;
    }
    else{
        return p2;
    }
}


// Function to calculate the angle between a line and the x-axis
function calculateAngleInRadianWithXAxis(line) {
    const [p1, p2] = line;
    
    // Ensure the points are different
    if (closeEnoughPoints(p1, p2)) {
        throw new Error("The two points must be distinct.");
    }
    // the line is vertical
    else if (closeEnoughScalars(p1. x, p2.x)) {
        return Math.PI / 2;
    }
    else{
        const deltaX = p2.x - p1.x;
        const deltaY = p2.y - p1.y;
        return angleInRadians = Math.atan2(deltaY, deltaX);  // -pi <= theta <= pi
    }
}

// Function to calculate the isogonal conjugate of a point P with respect to a triangle
function calculateIsogonalConjugate(points, p) {
    // let the reflections of P in the sidelines BC, CA, AB be Pa, Pb, Pc.
    // Then the center of the circle that passes through Pa, Pb and Pc is the isogonal conjugate of P.
    const [A, B, C] = points;
    const PA = reflectPointAcrossLine(p, [B, C]);
    const PB = reflectPointAcrossLine(p, [C, A]);
    const PC = reflectPointAcrossLine(p, [A, B]);
    return calculateCircumcenter([PA, PB, PC]);
}

// Function to convert barycentric coordinates to Cartesian coordinates
function barycentricToCartesian(points, bary) {
    const [A, B, C] = points;
    const [u, v, w] = bary;
    const x = (u * A.x + v * B.x + w * C.x) / (u + v + w);
    const y = (u * A.y + v * B.y + w * C.y) / (u + v + w);
    return { x, y };
}

// Function to convert trilinear coordinates to Cartesian coordinates
function trilinearToCartesian(points, trilinear) {
    const [A, B, C] = points;
    const [alpha, beta, gamma] = trilinear;
    // Calculate the side lengths of the triangle
    const a = calculateDistance(B, C);
    const b = calculateDistance(C, A);
    const c = calculateDistance(A, B);

    // Convert trilinear coordinates to barycentric coordinates
    const u = alpha * a;
    const v = beta * b;
    const w = gamma * c;

    // Use the barycentricToCartesian function to get Cartesian coordinates
    return barycentricToCartesian(points, [u, v, w]);
}

// Function to calculate the excenter for the vertex B (intersection of the internal angle bisectors of the vertex and other external angle bisectors)
function calculateExcenter(points) {
    if (useHomogeneousCoordinates) {
        return trilinearToCartesian(points, [1, -1, 1]);
    }
    const [A, B, C] = points;
    // Lengths of the triangle sides opposite to each vertex
    const a =  calculateDistance(B, C); // Length of side BC
    const b =  calculateDistance(C, A); // Length of side CA
    const c =  calculateDistance(A, B); // Length of side AB

    // Excenter formula for vertex B (opposite to side AC)
    return {
        x: (-b * B.x + c * C.x + a * A.x) / (-b + c + a),
        y: (-b * B.y + c * C.y + a * A.y) / (-b + c + a)
    }
}

// Function to calculate the three excenters
function calculateExcenters(points) {
    return [
        calculateExcenter([points[2], points[0], points[1]]),
        calculateExcenter(points),
        calculateExcenter([points[1], points[2], points[0]]),
    ];
}

// Function to calculate the Brocard points
function calculateBrocardPoint(points, number = 1) {
    const [A, B, C] = points;
    // Lengths of the triangle sides opposite to each vertex
    const a =  calculateDistance(B, C); 
    const b =  calculateDistance(C, A); 
    const c =  calculateDistance(A, B);
    // Determine whether the vertices are labeled in counterclockwise order
    const isCounterclockwise =  isCounterclockwiseOrder(points);

    if (useHomogeneousCoordinates) {
        let barycentric;
        switch (number) {
            case 1:
                if (isCounterclockwise){
                    barycentric = [c*a/b, a*b/c, b*c/a];
                }
                else{
                    barycentric = [a*b/c, b*c/a, c*a/b];
                }
                break;
            case 2:
                if (isCounterclockwise){
                    barycentric = [a*b/c, b*c/a, c*a/b];
                }
                else{
                    barycentric = [c*a/b, a*b/c, b*c/a];
                }
                break;
            case 3:
                barycentric = [1/(a**2), 1/(b**2), 1/(c**2)];
                break;
            default:
                console.error(`Unknown number: ${number}`);
                return;
        }
        return barycentricToCartesian(points, barycentric);
    }

    switch (number) {
        case 1:
            if (isCounterclockwise){                
                const circleA = calculateCircleTangentToLine(C, B, A);
                const circleB = calculateCircleTangentToLine(A, C, B);
                const circleC = calculateCircleTangentToLine(B, A, C);
                circle = calculateIntersectionOfThreeCircles(circleA, circleB, circleC);
            }
            else{
                const circleA = calculateCircleTangentToLine(B, C, A);
                const circleB = calculateCircleTangentToLine(C, A, B);
                const circleC = calculateCircleTangentToLine(A, B, C);
                circle = calculateIntersectionOfThreeCircles(circleA, circleB, circleC);
            }
            break;
        case 2:
            if (isCounterclockwise){
                const circleA = calculateCircleTangentToLine(B, C, A);
                const circleB = calculateCircleTangentToLine(C, A, B);
                const circleC = calculateCircleTangentToLine(A, B, C);
                circle = calculateIntersectionOfThreeCircles(circleA, circleB, circleC);
            }
            else{
                const circleA = calculateCircleTangentToLine(C, B, A);
                const circleB = calculateCircleTangentToLine(A, C, B);
                const circleC = calculateCircleTangentToLine(B, A, C);
                circle = calculateIntersectionOfThreeCircles(circleA, circleB, circleC);
            }
            break;
        case 3:
            circle = calculateBrocardMidpoint(calculateAnticomplementaryTriangle(points));
            break;
        default:
            console.error(`Unknown number: ${number}`);
            return;
    }
    return circle;
}

// Function to calculate the centroid of the triangle
function calculateCentroid(points) {
    if (useHomogeneousCoordinates) {
        return barycentricToCartesian(points, [1, 1, 1]);
    }
    const [A, B, C] = points;
    const x = ((A.x + B.x + C.x) / 3);
    const y = ((A.y + B.y + C.y) / 3);
    return { x, y };
}

// Function to calculate the circumcenter (intersection of perpendicular bisectors)
function calculateCircumcenter(points) {
    const [A, B, C] = points;

    if (useHomogeneousCoordinates) {
        const a = calculateDistance(B, C);
        const b = calculateDistance(C, A);
        const c = calculateDistance(A, B);
        const barycentric = [
            a**2 * (b**2 + c**2 - a**2),
            b**2 * (c**2 + a**2 - b**2),
            c**2 * (a**2 + b**2 - c**2),
        ]
        return barycentricToCartesian(points, barycentric);
    }

    // Midpoints of sides
    const D = { x: (A.x + B.x) / 2, y: (A.y + B.y) / 2 };
    const E = { x: (B.x + C.x) / 2, y: (B.y + C.y) / 2 };

    // Slopes of perpendicular bisectors
    const perpendicularSlopeAB = perpendicularSlope(calculateSlope(A, B));
    const perpendicularSlopeBC = perpendicularSlope(calculateSlope(B, C));

    // Circumcenter calculation
    return lineIntersectionGivenSlopesAndPoints(perpendicularSlopeAB, D, perpendicularSlopeBC, E);
}

// Function to calculate the incenter (intersection of angle bisectors)
function calculateIncenter(points) {
    if (useHomogeneousCoordinates) {
        return trilinearToCartesian(points, [1, 1, 1]);
    }
    const [A, B, C] = points;

    // Lengths of the sides
    const a = calculateDistance(B, C);
    const b = calculateDistance(C, A);
    const c = calculateDistance(A, B);

    // Incenter coordinates
    const x = (a * A.x + b * B.x + c * C.x) / (a + b + c);
    const y = (a * A.y + b * B.y + c * C.y) / (a + b + c);

    return { x, y };
}

// Function to calculate the orthocenter (intersection of perpendiculars)
function calculateOrthocenter(points) {
    const [A, B, C] = points;

    if (useHomogeneousCoordinates) {
        const a = calculateDistance(B, C);
        const b = calculateDistance(C, A);
        const c = calculateDistance(A, B);
        const barycentric = [
            1 / (b**2 + c**2 - a**2),
            1 / (c**2 + a**2 - b**2),
            1 / (a**2 + b**2 - c**2),
        ]
        return barycentricToCartesian(points, barycentric);
    }

    // Calculate perpendiculars
    const perpendicularSlopeAB = perpendicularSlope(calculateSlope(A, B));
    const perpendicularSlopeBC = perpendicularSlope(calculateSlope(B, C));

    // Solve for the intersection of the two perpendiculars (Orthocenter)
    return lineIntersectionGivenSlopesAndPoints(perpendicularSlopeAB, C, perpendicularSlopeBC, A);
}

// Function to calculate the isogonic center
function calculateIsogonicCenter(points, outer = true) {
    const [A, B, C] = points;

    if (!outer){
        if (isEquilateralTriangle(points)){
            return null;
        } 
    }

    // Determine rotation direction based on the cross product of vectors AB and AC
    const crossProduct = calculateCrossProduct(A, B, C);
    let rotationRadian = crossProduct > 0 ? -60 : 60;
    if (!outer){
        rotationRadian = -rotationRadian;
    }

    // Calculate rotation points for Fermat point
    const R1 = rotate(B, A, rotationRadian); // Rotate B 60 degrees around A
    const R2 = rotate(C, A, -rotationRadian); // Rotate C 60 degrees around A

    // Intersection of lines BR2 and CR1 gives the Fermat point
    return lineIntersection(B, R2, C, R1);
}

// Function to calculate the isodynamic point
function calculateIsodynamicPoint(points, outer = false) {
    if (outer) {
        if (isEquilateralTriangle(points)){
            return null;
        }    
    }
    const [A, B, C] = points;

    // Determine rotation direction based on the cross product of vectors AB and AC
    const crossProduct = calculateCrossProduct(A, B, C);
    let rotationRadian = crossProduct > 0 ? -60 : 60;
    if (!outer){
        rotationRadian = -rotationRadian;
    }

    // Calculate rotation points for Fermat point
    const P1 = rotate(C, B, rotationRadian);
    const P2 = rotate(A, C, rotationRadian);
    const Q1 = reflectPointAcrossLine(A, [B, C]);
    const Q2 = reflectPointAcrossLine(B, [C, A]);

    // Intersection of lines BR2 and CR1 gives the Fermat point
    return lineIntersection(P1, Q1, P2, Q2);
}

// Function to calculate the isogonic center
function calculateFermatPoint(points) {
    const [A, B, C] = points;
    
    // Check for angles >= 120 degrees
    if (calculateAngleInDegrees(B, A, C) >= 120) {
        return A;
    } else if (calculateAngleInDegrees(A, B, C) >= 120) {
        return B;
    } else if (calculateAngleInDegrees(A, C, B) >= 120) {
        return C;
    }
    else{
        return calculateIsogonicCenter(points, outer = true);
    }
}

// Function to calculate the Clawson point
function calculateClawsonPoint(points) {
    const [A, B, C] = points;
    if (useHomogeneousCoordinates) {
        const tanA = Math.tan(calculateAngleInRadians(C, A, B));
        const tanB = Math.tan(calculateAngleInRadians(A, B, C));
        const tanC = Math.tan(calculateAngleInRadians(B, C, A));
        trilinearToCartesian(points, [tanA, tanB, tanC]);
    }
    const AymeTriangle = calculateAymeTriangle(points);
    return lineIntersection(A, AymeTriangle[0], B, AymeTriangle[1]);
}

// Function to calculate the de Longchamps point that is the reflection of the orthocenter of the triangle about the circumcenter
function calculateDeLongchampsPoint(points) {
    const [A, B, C] = points;
    const orthocenter = calculateOrthocenter(points);
    const circumcenter = calculateCircumcenter(points);
    return {
        x: 2 * circumcenter.x - orthocenter.x,
        y: 2 * circumcenter.y - orthocenter.y,
    }
}

// Function to calculate the Schiffler point
function calculateSchifflerPoint(points) {
    const [A, B, C] = points;
    const incenter = calculateIncenter(points);
    const EulerLineA = calculateEulerLine([B, C, incenter]);
    const EulerLineB = calculateEulerLine([C, A, incenter]);
    return lineIntersection(EulerLineA[0], EulerLineA[1], EulerLineB[0], EulerLineB[1]);
}

// Function to calculate the Exeter point
function calculateExeterPoint(points) {
    if (useHomogeneousCoordinates) {
        const [A, B, C] = points;
        const a = calculateDistance(B, C);
        const b = calculateDistance(C, A);
        const c = calculateDistance(A, B);
        const a4 = a*a*a*a;
        const b4 = b*b*b*b;
        const c4 = c*c*c*c;
        return barycentricToCartesian(points, [a*a*(b4+c4-a4), b*b*(c4+a4-b4), c*c*(a4+b4-c4)]);
    }
    const tangentialTriangle = calculateTangentialTriangle(points);
    const circumMedialTriangle = calculateCircumMedialTriangle(points);
    return lineIntersection(tangentialTriangle[0], circumMedialTriangle[0], tangentialTriangle[1], circumMedialTriangle[1]);
}

// Function to calculate the far-out point
function calculateFarOutPoint(points) {
    // a[b4 + c4 - a4 - b2c2] 
    if (isEquilateralTriangle(points)) {
        return null;
    }
    const [A, B, C] = points;
    if (useHomogeneousCoordinates) {
        const a = calculateDistance(B, C);
        const b = calculateDistance(C, A);
        const c = calculateDistance(A, B);
        const a2 = a*a;
        const b2 = b*b;
        const c2 = c*c;
        const a4 = a2*a2;
        const b4 = b2*b2;
        const c4 = c2*c2;
        const trilinearA = a * (b4 + c4 - a4 - b2 * c2);
        const trilinearB = b * (c4 + a4 - b4 - c2 * a2);
        const trilinearC = c * (a4 + b4 - c4 - a2 * b2);
        return trilinearToCartesian(points, [trilinearA, trilinearB, trilinearC]);
    }
    const circumcenter = calculateCircumcenter(points);
    const [PA, PB, PC] = calculateTangentialTriangle(points);
    const circumcircleA = calculateCircumcircle([A, PA, circumcenter]);
    const circumcircleB = calculateCircumcircle([B, PB, circumcenter]);
    const circumcircleC = calculateCircumcircle([C, PC, circumcenter]);
    const [P1, P2] = calculateIntersectionOfTwoCircles(circumcircleA, circumcircleB);
    return (calculateDistance(P1, circumcenter) > calculateDistance(P2, circumcenter))? P1 : P2;
}

// Function to calculate the nine point center
function calculateNinePointCenter(points) {
    if (useHomogeneousCoordinates) {
        const [A, B, C] = points;
        const a = calculateDistance(B, C);
        const b = calculateDistance(C, A);
        const c = calculateDistance(A, B);
        const barycentric = [
            a**2 * (b**2 + c**2) - (b**2 - c**2)**2,
            b**2 * (c**2 + a**2) - (c**2 - a**2)**2,
            c**2 * (a**2 + b**2) - (a**2 - b**2)**2,
        ]
        return barycentricToCartesian(points, barycentric);
    }
    // Calculate the center and radius
    // The center is the midpoint between the orthocenter and circumcenter.
    // The radius is half of the circumradius.
    const orthocenter = calculateOrthocenter(points);
    const circumcircle = calculateCircumcircle(points);
    const circumcenter = circumcircle.center;
    return {
        x: (orthocenter.x + circumcenter.x)/2,
        y: (orthocenter.y + circumcenter.y)/2
    };
}

// Function to calculate the Napoleon points
function calculateNapoleonPoint(points, outer = true) {
    const [A, B, C] = points;
    const [D, E, F] = calculateNapoleonTriangle(points, outer = outer);
    return lineIntersection(A, D, B, E);
}

// Function to calculate the symmedian point
function calculateSymmedianPoint(points) {
    const [A, B, C] = points;
    if (useHomogeneousCoordinates) {
        const a = calculateDistance(B, C);
        const b = calculateDistance(C, A);
        const c = calculateDistance(A, B);
        return barycentricToCartesian(points, [a**2, b**2, c**2]);
    }
    // The circumcircle of triangle ABC and the tangents at each vertex.
    const circumcenter = calculateCircumcenter(points);
    const tangentSlopeA = perpendicularSlope(calculateSlope(circumcenter, A));
    const tangentSlopeB = perpendicularSlope(calculateSlope(circumcenter, B));
    const tangentSlopeC = perpendicularSlope(calculateSlope(circumcenter, C));
    // calculate symmedians
    const P1 = lineIntersectionGivenSlopesAndPoints(tangentSlopeB, B, tangentSlopeC, C);
    const P2 = lineIntersectionGivenSlopesAndPoints(tangentSlopeA, A, tangentSlopeC, C);
    return lineIntersection(A, P1, B, P2);
}


// Function to calculate the Gergonne point
function calculateGergonnePoint(points) {
    const GergonneTriangle = calculateIntouchTriangle(points);
    return lineIntersection(points[0], GergonneTriangle[0], points[1], GergonneTriangle[1]);
}

// Function to calculate the Nagel point
function calculateNagelPoint(points) {
    const extouchTriangle = calculateExtouchTriangle(points);
    return lineIntersection(points[0], extouchTriangle[0], points[1], extouchTriangle[1]);
}

// Function to calculate the Brocard midpoint
function calculateBrocardMidpoint(points) {
    const firstBrocardPoint = calculateBrocardPoint(points, number = 1);
    const secondBrocardPoint = calculateBrocardPoint(points, number = 2);
    return midpoint(firstBrocardPoint, secondBrocardPoint);
}

// Function to calculate the Bevan point
function calculateBevanPoint(points) {
    return calculateBevanCircle(points).center;
}

// Function to calculate the Kosnita point
function calculateKosnitaPoint(points) {
    const [A, B, C] = points;
    if (useHomogeneousCoordinates) {        
        const a = calculateDistance(B, C);
        const b = calculateDistance(C, A);
        const c = calculateDistance(A, B);
        barycentric1 = a**2 / (b**4 + c**4 - (a**2)*(b**2) - 2*(b**2)*(c**2) - (c**2)*(a**2));
        barycentric2 = b**2 / (c**4 + a**4 - (b**2)*(c**2) - 2*(c**2)*(a**2) - (a**2)*(b**2));
        barycentric3 = c**2 / (a**4 + b**4 - (c**2)*(a**2) - 2*(a**2)*(b**2) - (b**2)*(c**2));
        return barycentricToCartesian(points, [barycentric1, barycentric2, barycentric3]);
    }
    const O = calculateCircumcenter(points);
    const OA = calculateCircumcenter([B, C, O]);
    const OB = calculateCircumcenter([C, A, O]);
    return lineIntersection(A, OA, B, OB);
}

// Function to calculate the Prasolov point
function calculatePrasolovPoint(points) {
    const [A, B, C] = points;
    if (useHomogeneousCoordinates) {
        const a = calculateDistance(B, C);
        const b = calculateDistance(C, A);
        const c = calculateDistance(A, B);
        const a2 = a*a;
        const b2 = b*b;
        const c2 = c*c;
        const a4 = a2*a2;
        const b4 = b2*b2;
        const c4 = c2*c2;
        const barycentricA = (b2 + c2 - a2) / (a4 + b4 + c4 - 2*a2*b2 - 2*c2*a2);
        const barycentricB = (c2 + a2 - b2) / (b4 + c4 + a4 - 2*b2*c2 - 2*a2*b2);
        const barycentricC = (a2 + b2 - c2) / (c4 + a4 + b4 - 2*c2*a2 - 2*b2*c2);
        return barycentricToCartesian(points, [barycentricA, barycentricB, barycentricC]);
    }
    const ninePointCenter = calculateNinePointCenter(points);
    const [PA, PB, PC] = calculateOrthicTriangle(points);
    const QA = reflectPointAcrossCenter(PA, ninePointCenter);
    const QB = reflectPointAcrossCenter(PB, ninePointCenter);
    return lineIntersection(A, QA, B, QB);
}

// Function to calculate the Tarry point
function calculateTarryPoint(points) {
    if (isEquilateralTriangle(points)) {
        return null;
    }
    const [A, B, C] = points;
    if (useHomogeneousCoordinates) {
        const a = calculateDistance(B, C);
        const b = calculateDistance(C, A);
        const c = calculateDistance(A, B);
        const a2 = a*a;
        const b2 = b*b;
        const c2 = c*c;
        const a4 = a2*a2;
        const b4 = b2*b2;
        const c4 = c2*c2;
        const barycentricA = 1 / (b4 + c4 - a2*b2 - c2*a2);
        const barycentricB = 1 / (c4 + a4 - b2*c2 - a2*b2);
        const barycentricC = 1 / (a4 + b4 - c2*a2 - b2*c2);
        return barycentricToCartesian(points, [barycentricA, barycentricB, barycentricC]);
    }
    const firstBrocardTriangle = calculateBrocardTriangle(points, 1);
    const [D, E, F] = firstBrocardTriangle;
    const perpendicularSlopeA = perpendicularSlope(calculateSlope(E, F));
    const perpendicularSlopeB = perpendicularSlope(calculateSlope(F, D));
    return lineIntersectionGivenSlopesAndPoints(perpendicularSlopeA, A, perpendicularSlopeB, B);
}


// Function to calculate the Steiner point
function calculateSteinerPoint(points) {
    if (isEquilateralTriangle(points)) {
        return null;
    }
    const [A, B, C] = points;
    if (useHomogeneousCoordinates) {
        const a = calculateDistance(B, C);
        const b = calculateDistance(C, A);
        const c = calculateDistance(A, B);
        const a2 = a*a;
        const b2 = b*b;
        const c2 = c*c;
        return barycentricToCartesian(points, [1/(b2-c2), 1/(c2-a2), 1/(a2-b2)]);
    }
    const circumcenter = calculateCircumcenter(points);
    const symmedianPoint = calculateSymmedianPoint(points);
    const cA = reflectPointAcrossLine(circumcenter, [B, C]);
    const sA = reflectPointAcrossLine(symmedianPoint, [B, C]);
    const cB = reflectPointAcrossLine(circumcenter, [C, A]);
    const sB = reflectPointAcrossLine(symmedianPoint, [C, A]);
    const cC = reflectPointAcrossLine(circumcenter, [A, B]);
    const sC = reflectPointAcrossLine(symmedianPoint, [A, B]);
    const AA = lineIntersection(cB, sB, cC, sC);
    const BB = lineIntersection(cC, sC, cA, sA);
    return lineIntersection(A, AA, B, BB);
}


// Function to calculate the focus of Kiepert parabola
function calculateFocusOfKiepertParabola(points) {
    if (isEquilateralTriangle(points)) {
        return null;
    }
    const [A, B, C] = points;
    if (useHomogeneousCoordinates) {
        const a = calculateDistance(B, C);
        const b = calculateDistance(C, A);
        const c = calculateDistance(A, B);
        const a2 = a*a;
        const b2 = b*b;
        const c2 = c*c;
        return barycentricToCartesian(points, [a2/(b2-c2), b2/(c2-a2), c2/(a2-b2)]);
    }
    const centroid = calculateCentroid(points);
    const PA = reflectPointAcrossLine(centroid, [B, C]);
    const PB = reflectPointAcrossLine(centroid, [C, A]);
    const PC = reflectPointAcrossLine(centroid, [A, B]);
    const circumcircleA = calculateCircumcircle([A, PB, PC]);
    const circumcircleB = calculateCircumcircle([B, PC, PA]);
    const circumcircleC = calculateCircumcircle([C, PA, PB]);
    return calculateIntersectionOfThreeCircles(circumcircleA, circumcircleB, circumcircleC);
}

// Function to calculate the focus of Kiepert parabola
function calculateParryPoint(points) {
    if (isEquilateralTriangle(points)) {
        return null;
    }
    if (useHomogeneousCoordinates) {
        const [A, B, C] = points;
        const a = calculateDistance(B, C);
        const b = calculateDistance(C, A);
        const c = calculateDistance(A, B);
        const a2 = a*a;
        const b2 = b*b;
        const c2 = c*c;
        return barycentricToCartesian(points, [a2/(2*a2-b2-c2), b2/(2*b2-c2-a2), c2/(2*c2-a2-b2)]);
    }
    const ParryCircle = calculateParryCircle(points);
    const circumcircle = calculateCircumcircle(points);
    const [p1, p2] = calculateIntersectionOfTwoCircles(ParryCircle, circumcircle);
    const focusOfKiepertParabola = calculateFocusOfKiepertParabola(points);
    if (calculateDistance(p1, focusOfKiepertParabola) > calculateDistance(p2, focusOfKiepertParabola)) {
        return p1;
    }
    else {
        return p2;
    }
}

// Function to calculate the first Ajima-Malfatti point
function calculateFirstAjimaMalfattiPoint(points) {
    const [A, B, C] = points;
    const MalfattiCircles = calculateMalfattiCircles(points);
    const [cA, cB, cC] = MalfattiCircles;
    // calculate the tangency points of two Malfatti circles
    const PA = {
        x: (cC.radius * cB.center.x + cB.radius * cC.center.x) / (cB.radius + cC.radius),
        y: (cC.radius * cB.center.y + cB.radius * cC.center.y) / (cB.radius + cC.radius)
    };
    const PB = {
        x: (cA.radius * cC.center.x + cC.radius * cA.center.x) / (cC.radius + cA.radius),
        y: (cA.radius * cC.center.y + cC.radius * cA.center.y) / (cC.radius + cA.radius)
    };
    return lineIntersection(A, PA, B, PB);
}

// Function to calculate the second Ajima-Malfatti point
function calculateSecondAjimaMalfattiPoint(points) {
    const [A, B, C] = points;
    const MalfattiCircles = calculateMalfattiCircles(points);
    const [cA, cB, cC] = MalfattiCircles;
    const excenterA = calculateExcenter([C, A, B]);
    const excenterB = calculateExcenter([A, B, C]);
    // calculate the tangency points of two Malfatti circles
    const PA = {
        x: (cC.radius * cB.center.x + cB.radius * cC.center.x) / (cB.radius + cC.radius),
        y: (cC.radius * cB.center.y + cB.radius * cC.center.y) / (cB.radius + cC.radius)
    };
    const PB = {
        x: (cA.radius * cC.center.x + cC.radius * cA.center.x) / (cC.radius + cA.radius),
        y: (cA.radius * cC.center.y + cC.radius * cA.center.y) / (cC.radius + cA.radius)
    };
    return lineIntersection(excenterA, PA, excenterB, PB);
}

// Function to calculate the Mittenpunkt
function calculateMittenpunkt(points) {
    const excentralTriangle = calculateExcentralTriangle(points);
    return calculateSymmedianPoint(excentralTriangle);
}

// Function to calculate the Spieker center
function calculateSpiekerCenter(points) {
    const medialTriangle = calculateMedialTriangle(points);
    return calculateIncenter(medialTriangle);
}

// Function to calculate the Feuerbach point
function calculateFeuerbachPoint(points) {
    const incircle = calculateIncircle(points);
    const ninePointCircle = calculateNinePointCircle(points);
    return calculateTangencyPoint(incircle, ninePointCircle);
}

// Function to calculate the equal parallelians point
function calculateEqualParalleliansPoint(points) {
    const [A, B, C] = points;
    if(useHomogeneousCoordinates) {
        const a = calculateDistance(B, C);
        const b = calculateDistance(C, A);
        const c = calculateDistance(A, B);
        return barycentricToCartesian(points, [c*a+a*b-b*c, a*b+b*c-c*a, b*c+c*a-a*b]);
    }
    const anticomplementaryTriangle = calculateAnticomplementaryTriangle(points);
    const internalAngleBisectors = calculateInternalAngleBisectors(points);
    const PA = lineIntersection(...internalAngleBisectors[0], B, C);
    const PB = lineIntersection(...internalAngleBisectors[1], C, A);
    return lineIntersection(anticomplementaryTriangle[0], PA, anticomplementaryTriangle[1], PB);
}

// Function to calculate the Fuhrmann center
function calculateFuhrmannCenter(points) {
    return calculateCircumcircle(calculateFuhrmannTriangle(points)).center;
}

// Function to calculate the Kenmotu point
function calculateKenmotuPoint(points, outer = true) {
    if (useHomogeneousCoordinates) {
        const [A, B, C] = points;
        const tempConst = outer ? 1 : -1;
        const cosA = calculateCosine(C, A, B);
        const cosB = calculateCosine(A, B, C);
        const cosC = calculateCosine(B, C, A);
        const sinA = calculateSine(C, A, B);
        const sinB = calculateSine(A, B, C);
        const sinC = calculateSine(B, C, A);
        return trilinearToCartesian(points, [sinA + tempConst*cosA, sinB + tempConst*cosB, sinC + tempConst*cosC]);
    }
    return calculateIsogonalConjugate(points, calculateVectenPoint(points, outer));
}

// Function to calculate the Vecten points
function calculateVectenPoint(points, outer = true) {
    const [A, B, C] = points;
    if (useHomogeneousCoordinates) {
        const tempConst = outer ? 1 : -1;
        const cosA = calculateCosine(C, A, B);
        const cosB = calculateCosine(A, B, C);
        const cosC = calculateCosine(B, C, A);
        const sinA = calculateSine(C, A, B);
        const sinB = calculateSine(A, B, C);
        const sinC = calculateSine(B, C, A);
        return trilinearToCartesian(points, [1 / (sinA + tempConst*cosA), 1 / (sinB + tempConst*cosB), 1 / (sinC + tempConst*cosC)]);
    }
    const [PA, PB, PC] = calculateVectenTriangle(points, outer);
    return lineIntersection(A, PA, B, PB);
}

// Function to calculate the Evans point
function calculateEvansPoint(points) {
    if (!isScaleneTriangle(points)){
        return null;
    }
    if (useHomogeneousCoordinates){
        const [A, B, C] = points;
        const a = calculateDistance(B, C);
        const b = calculateDistance(C, A);
        const c = calculateDistance(A, B);
        const cosA = calculateCosine(C, A, B);
        const cosB = calculateCosine(A, B, C);
        const cosC = calculateCosine(B, C, A);
        const barycentric1 = -2*(a**2)*cosA+b*(a-b+c)*cosB+c*(a+b-c)*cosC;
        const barycentric2 = -2*(b**2)*cosB+c*(b-c+a)*cosC+a*(b+c-a)*cosA;
        const barycentric3 = -2*(c**2)*cosC+a*(c-a+b)*cosA+b*(c+a-b)*cosB;
        return barycentricToCartesian(points, [barycentric1, barycentric2, barycentric3]);
    }
    const EulerLine = calculateEulerLine(points);
    const GergonneLine = calculateGergonneLine(points);
    return lineIntersection(...EulerLine, ...GergonneLine);
}

// Function to calculate the sidelines (extended side)
function calculateSidelines(points) {
    const [A, B, C] = points;
    return [
        [B, C],
        [C, A],
        [A, B]
    ];
}


// Function to calculate the medians
function calculateMedians(points) {
    const [A, B, C] = points;
    const centroid = calculateCentroid(points);
    return [
        [A, centroid],
        [B, centroid],
        [C, centroid]
    ];
}

// Function to calculate the perpendicular bisectors
function calculatePerpendicularBisectors(points) {
    const [A, B, C] = points;
    const circumcenter = calculateCircumcenter(points);
    return [
        [midpoint(B, C), circumcenter],
        [midpoint(C, A), circumcenter],
        [midpoint(A, B), circumcenter]
    ];
}


// Function to calculate the internal angle bisectors
function calculateInternalAngleBisectors(points) {
    const [A, B, C] = points;
    const incenter = calculateIncenter(points);
    return [
        [A, incenter],
        [B, incenter],
        [C, incenter]
    ];
}

// Function to calculate the altitudes
function calculateAltitudes(points) {
    const [A, B, C] = points;
    const orthocenter = calculateOrthocenter(points);
    return [
        [A, orthocenter],
        [B, orthocenter],
        [C, orthocenter]
    ];
}

// Function to calculate the symmedians
function calculateSymmedians(points) {
    const [A, B, C] = points;
    const symmedianPoint = calculateSymmedianPoint(points);
    return [
        [A, symmedianPoint],
        [B, symmedianPoint],
        [C, symmedianPoint]
    ];
}

// Function to calculate the exsymmedians
function calculateExsymmedians(points) {
    const [A, B, C] = points;
    const circumcenter = calculateCircumcenter(points);
    const slopeA = perpendicularSlope(calculateSlope(A, circumcenter));
    const slopeB = perpendicularSlope(calculateSlope(B, circumcenter));
    const slopeC = perpendicularSlope(calculateSlope(C, circumcenter));
    return [
        SlopeAndPointToLine(slopeA, A),
        SlopeAndPointToLine(slopeB, B),
        SlopeAndPointToLine(slopeC, C),
    ];
}

// Function to calculate the splitters
function calculateSplitters(points) {
    const [A, B, C] = points;
    const NagelPoint = calculateNagelPoint(points);
    return [
        [A, NagelPoint],
        [B, NagelPoint],
        [C, NagelPoint]
    ];
}

// Function to calculate the cleavers
function calculateCleavers(points) {
    const [A, B, C] = points;
    const SpiekerCenter = calculateSpiekerCenter(points);
    return [
        [midpoint(B, C), SpiekerCenter],
        [midpoint(C, A), SpiekerCenter],
        [midpoint(A, B), SpiekerCenter]
    ];
}


// Function to calculate the Euler line
function calculateEulerLine(points) {
    if (isEquilateralTriangle(points)) {
        return null;
    }
    const orthocenter = calculateOrthocenter(points);
    const circumcenter = calculateCircumcenter(points);
    return [orthocenter, circumcenter];
}

// Function to calculate the Gergonne line
function calculateGergonneLine(points) {
    if (!isScaleneTriangle(points)) {
        return null;
    }
    const [A, B, C] = points;
    const [D, E, F] = calculateIntouchTriangle(points);
    return [
        lineIntersection(A, B, D, E),
        lineIntersection(B, C, E, F)
    ];
}

// Function to calculate the Nagel line
function calculateNagelLine(points) {
    if (isEquilateralTriangle(points)) {
        return null;
    }
    return [
        calculateIncenter(points),
        calculateNagelPoint(points)
    ];
}

// Function to calculate the van Aubel line
function calculateVanAubelLine(points) {
    if (isEquilateralTriangle(points)) {
        return null;
    }
    return [
        calculateOrthocenter(points),
        calculateSymmedianPoint(points)
    ];
}

// Function to calculate the Brocard axis
function calculateBrocardAxis(points) {
    if (isEquilateralTriangle(points)) {
        return null;
    }
    return[
        calculateSymmedianPoint(points),
        calculateCircumcenter(points)
    ];
}


// Function to calculate the Fermat axis
function calculateFermatAxis(points) {
    if (isEquilateralTriangle(points)) {
        return null;
    }
    return[
        calculateIsogonicCenter(points, outer = true),
        calculateIsogonicCenter(points, outer = false)
    ];
}

// Function to calculate the Orthic axis
function calculateOrthicAxis(points) {
    if (!isScaleneTriangle(points)) {
        return null;
    }
    const [A, B, C] = points;
    const [D, E, F] = calculateOrthicTriangle(points);
    return [
        lineIntersection(A, B, D, E),
        lineIntersection(B, C, E, F)
    ];
}

// Function to calculate the orthogonal regression line for three vertices
function calculateOrthogonalRegressionLine(points) {
    // Step 1: Calculate the sample means
    const n = points.length;
    const meanX = points.reduce((sum, p) => sum + p.x, 0) / n;
    const meanY = points.reduce((sum, p) => sum + p.y, 0) / n;

    // Step 2: Calculate second-degree sample moments
    let s_xx = 0, s_yy = 0, s_xy = 0;
    points.forEach(p => {
        s_xx += (p.x - meanX) * (p.x - meanX);
        s_yy += (p.y - meanY) * (p.y - meanY);
        s_xy += (p.x - meanX) * (p.y - meanY);
    });

    s_xx /= n;
    s_yy /= n;
    s_xy /= n;

    // Step 3: Calculate the slope (beta_1)
    // For delta = 1, the orthogonal regression slope is calculated using:
    const delta = 1;
    const numerator = s_yy - delta * s_xx + Math.sqrt((s_yy - delta * s_xx) ** 2 + 4 * delta * s_xy ** 2);
    const beta_1 = numerator / (2 * s_xy);

    // Step 4: Return the orthogonal regression line
    if (isFinite(beta_1)) {
        return [{x: meanX, y: meanY}, {x: meanX + 1, y: meanY + beta_1}];
    }
    else {
        return [{x: meanX, y: meanY}, {x: meanX, y: meanY + 1}];
    }
}

// Function to calculate the KiepertParabola
function calculateKiepertParabola(points) {
    if (isEquilateralTriangle(points)) {
        return null;
    }
    return {
        focus: calculateFocusOfKiepertParabola(points),
        directrix: calculateEulerLine(points)
    }
}


// Function to calculate the incircle
function calculateIncircle(points) {
    const [A, B, C] = points;
    // Calculate the incenter (already defined)
    const incenter = calculateIncenter(points);

    // Calculate the radius of the incircle using the formula: 2 * area / (a + b + c)
    const a = calculateDistance(B, C);
    const b = calculateDistance(C, A);
    const c = calculateDistance(A, B);
    const area = calculateArea(points);
    const radius = 2 * area / (a + b + c);

    // Return the circle object with center and radius
    return {
        center: incenter,
        radius: radius
    };
}


// Function to calculate the circumcircle
function calculateCircumcircle(points) {
    const [A, B, C] = points;
    const center = calculateCircumcenter(points);

    // Calculate the circumradius using the formula R = (a * b * c) / (4 * area)
    const a = calculateDistance(B, C);
    const b = calculateDistance(A, C);
    const c = calculateDistance(A, B);
    const area = calculateArea(points);
    const radius = (a * b * c) / (4 * area);

    // Return the circle object with center and radius
    return {
        center: center,
        radius: radius
    };
}

// Function to calculate the excircle opposite to the vertex B
function calculateExcircle(points) {
    const [A, B, C] = points;

    // Calculate the radius using the formula: 2 * area / (-a + b + c)
    const a = calculateDistance(B, C);
    const b = calculateDistance(C, A);
    const c = calculateDistance(A, B);
    const area = calculateArea(points);

    return {
        center: calculateExcenter(points),
        radius: 2 * area / (-b + c + a)
    };
}

// Function to calculate the three excircles
function calculateExcircles(points) {
    return [
        calculateExcircle([points[2], points[0], points[1]]),
        calculateExcircle(points),
        calculateExcircle([points[1], points[2], points[0]])
    ];
}

// Function to calculate the nine-point circle
function calculateNinePointCircle(points) {
    // Calculate the center and radius
    // The center is the midpoint between the orthocenter and circumcenter.
    // The radius is half of the circumradius.
    const circumcircle = calculateCircumcircle(points);

    // Return the circle object with center and radius
    return {
        center: calculateNinePointCenter(points),
        radius: circumcircle.radius / 2
    };
}

// Function to calculate the orthocentroidal circle
function calculateOrthocentroidalCircle(points) {
    if (isEquilateralTriangle(points)) {
        return null;
    }
    const centroid = calculateCentroid(points);
    const orthocenter = calculateOrthocenter(points);
    return {
        center: midpoint(centroid, orthocenter),
        radius: calculateDistance(centroid, orthocenter) / 2
    }
}

// Function to calculate the smallest circle that contains all vertices of the original triangle
function calculateSmallestCircle(points) {
    const [A, B, C] = points;
    const a = calculateDistance(B, C);
    const b = calculateDistance(C, A);
    const c = calculateDistance(A, B);
    if (b**2 + c**2 < a **2){ // when the angle A is obtuse 
        return{
            center: midpoint(B, C),
            radius: a / 2
        }
    }
    else if (a**2 + c**2 < b **2){ // when the angle B is obtuse 
        return{
            center: midpoint(A, C),
            radius: b / 2
        }
    }
    else if (a**2 + b**2 < c **2){ // when the angle C is obtuse 
        return{
            center: midpoint(A, B),
            radius: c / 2
        }
    }
    else{
        return calculateCircumcircle(points);
    }
}

// Function to calculate the Lester circle
function calculateLesterCircle(points) {
    if (!isScaleneTriangle(points)) {
        return null;
    }
    const firstIsogonicCenter = calculateIsogonicCenter(points, outer = true);
    const secondIsogonicCenter = calculateIsogonicCenter(points, outer = false);
    const circumcenter = calculateCircumcenter(points);
    return calculateCircumcircle([firstIsogonicCenter, secondIsogonicCenter, circumcenter]);
}

// Function to calculate the Bevan circle
function calculateBevanCircle(points) {
    const excentralTriangle = calculateExcentralTriangle(points);
    return calculateCircumcircle(excentralTriangle);
}

// Function to calculate the Spieker circle
function calculateSpiekerCircle(points) {
    const medialTriangle = calculateMedialTriangle(points);
    return calculateIncircle(medialTriangle);
}

// Function to calculate the Adams' circle
function calculateAdamsCircle(points) {
    const [A, B, C] = points;
    const slopeAB = calculateSlope(A, B);
    const slopeBC = calculateSlope(B, C);
    const slopeCA = calculateSlope(C, A);
    const GergonnePoint = calculateGergonnePoint(points);
    const GergonneTriangle = calculateIntouchTriangle(points);
    const slopeGTAB = calculateSlope(GergonneTriangle[0], GergonneTriangle[1]);
    const slopeGTBC = calculateSlope(GergonneTriangle[1], GergonneTriangle[2]);
    P1 = lineIntersectionGivenSlopesAndPoints(slopeGTAB, GergonnePoint, slopeBC, B);
    P2 = lineIntersectionGivenSlopesAndPoints(slopeGTAB, GergonnePoint, slopeCA, C);
    P3 = lineIntersectionGivenSlopesAndPoints(slopeGTBC, GergonnePoint, slopeAB, A);
    return calculateCircumcircle([P1, P2, P3]);  
}

// Function to calculate the Fuhrmann circle
function calculateFuhrmannCircle(points) {
    return calculateCircumcircle(calculateFuhrmannTriangle(points));
}

// Function to calculate the Mandart circle
function calculateMandartCircle(points) {
    return calculateCircumcircle(calculateExtouchTriangle(points));
}

// Function to calculate the Malfatti circles
function calculateMalfattiCircles(points) {
    // Function to calculate the center of Malfatti circles near the vertex A
    function calculateCenters(points, P, r) {
        const [A, B, C] = points;
        const perpendicularSlopeAB = perpendicularSlope(calculateSlope(A, B));
        const sqrtDenominator = Math.sqrt(perpendicularSlopeAB**2 + 1);
        // Two candidates of centers
        const P1 = {
            x: P.x + r / sqrtDenominator,
            y: isFinite(perpendicularSlopeAB) ? 
            P.y + r * perpendicularSlopeAB / sqrtDenominator
            : P.y + r
        };
        const P2 = {
            x: P.x - r / sqrtDenominator,
            y: isFinite(perpendicularSlopeAB) ? 
            P.y - r * perpendicularSlopeAB / sqrtDenominator
            : P.y - r
        };
        return (calculateCrossProduct(A, B, C) * calculateCrossProduct(A, B, P1) >= 0) ? P1 : P2;
    }
    const [A, B, C] = points;
    const a = calculateDistance(B, C);
    const b = calculateDistance(C, A);
    const c = calculateDistance(A, B);
    const incircle = calculateIncircle(points);
    const inradius = incircle.radius;
    const incenter = incircle.center;
    const IA = calculateDistance(incenter, A);
    const IB = calculateDistance(incenter, B);
    const IC = calculateDistance(incenter, C);
    const semiperimeter = (a + b + c) / 2;
    const rA = inradius * (semiperimeter - inradius + IA - IB - IC) / 2 / (semiperimeter-a);
    const rB = inradius * (semiperimeter - inradius - IA + IB - IC) / 2 / (semiperimeter-b);
    const rC = inradius * (semiperimeter - inradius - IA - IB + IC) / 2 / (semiperimeter-c);
    const radianA = calculateAngleInRadians(C, A, B);
    const radianB = calculateAngleInRadians(A, B, C);
    const radianC = calculateAngleInRadians(B, C, A);
    const dA = rA / Math.tan(radianA / 2);
    const dB = rB / Math.tan(radianB / 2);
    const dC = rC / Math.tan(radianC / 2);
    const PA = {x: ((c-dA)*A.x+dA*B.x)/c, y: ((c-dA)*A.y+dA*B.y)/c};
    const PB = {x: ((a-dB)*B.x+dB*C.x)/a, y: ((a-dB)*B.y+dB*C.y)/a};
    const PC = {x: ((b-dC)*C.x+dC*A.x)/b, y: ((b-dC)*C.y+dC*A.y)/b};
    const circleA = {center: calculateCenters([A, B, C], PA, rA), radius: rA};
    const circleB = {center: calculateCenters([B, C, A], PB, rB), radius: rB};
    const circleC = {center: calculateCenters([C, A, B], PC, rC), radius: rC};
    return [circleA, circleB, circleC];
}

// Function to calculate the Parry circle
function calculateParryCircle(points) {
    const centroid = calculateCentroid(points);
    const firstIsodynamicPoint = calculateIsodynamicPoint(points, outer = false);
    const secondIsodynamicPoint = calculateIsodynamicPoint(points, outer = true);
    return calculateCircumcircle([centroid, firstIsodynamicPoint, secondIsodynamicPoint]);
}

// Function to calculate the Brocard circle
function calculateBrocardCircle(points) {
    const circumcenter = calculateCircumcenter(points);
    const symmedianPoint = calculateSymmedianPoint(points);
    return {
        center: midpoint(circumcenter, symmedianPoint),
        radius: calculateDistance(circumcenter, symmedianPoint) / 2
    };
}

// Function to calculate the Taylor circle
function calculateTaylorCircle(points) {
    const [A, B, C] = points;
    const slopeAB = calculateSlope(A, B);
    const slopeBC = calculateSlope(B, C);
    const slopeCA = calculateSlope(C, A);
    const perpendicularSlopeAB = perpendicularSlope(slopeAB);
    const perpendicularSlopeBC = perpendicularSlope(slopeBC);
    const perpendicularSlopeCA = perpendicularSlope(slopeCA);
    const PA = lineIntersectionGivenSlopesAndPoints(perpendicularSlopeBC, A, slopeBC, B);
    const PB = lineIntersectionGivenSlopesAndPoints(perpendicularSlopeCA, B, slopeCA, C);
    const PAB = lineIntersectionGivenSlopesAndPoints(perpendicularSlopeCA, PA, slopeCA, C);
    const PAC = lineIntersectionGivenSlopesAndPoints(perpendicularSlopeAB, PA, slopeAB, A);
    const PBC = lineIntersectionGivenSlopesAndPoints(perpendicularSlopeAB, PB, slopeAB, A);
    return calculateCircumcircle([PAB, PAC, PBC]);
}

// Function to calculate the Van Lamoen circle
function calculateVanLamoenCircle(points) {
    const [A, B, C] = points;
    const centroid = calculateCentroid(points);
    const midpointBC = midpoint(B, C);
    const midpointCA = midpoint(C, A);
    const circumcenter1 = calculateCircumcenter([B, centroid, midpointBC]);
    const circumcenter2 = calculateCircumcenter([C, centroid, midpointBC]);
    const circumcenter3 = calculateCircumcenter([A, centroid, midpointCA]);
    return calculateCircumcircle([circumcenter1, circumcenter2, circumcenter3]);
}

// Function to calculate the first Lemoine circle
function calculateFirstLemoineCircle(points) {
    const LemoineHexagon = calculateLemoineHexagon(points);
    return calculateCircumcircle(LemoineHexagon.slice(0, 3));
}

// Function to calculate the cosine circle
function calculateCosineCircle(points) {
    const [A, B, C] = points;
    const a = calculateDistance(B, C);
    const b = calculateDistance(C, A);
    const c = calculateDistance(A, B);
    return {
        center: calculateSymmedianPoint(points),
        radius: a*b*c / (a**2 + b**2 + c**2)
    };
}

// Function to calculate the Kenmotu circle
function calculateKenmotuCircle(points) {
    const [A, B, C] = points;
    const a = calculateDistance(B, C);
    const b = calculateDistance(C, A);
    const c = calculateDistance(A, B);
    const area = calculateArea(points);
    return {
        center: calculateKenmotuPoint(points, true),
        radius: Math.sqrt(2)*a*b*c/(4*area + a**2 + b**2 + c**2)
    };
}

// Function to calculate the Conway circle
function calculateConwayCircle(points) {
    const incircle = calculateIncircle(points);
    const semiperimeter = calculateSemiperimeter(points);
    return {
        center: incircle.center,
        radius: Math.sqrt((incircle.radius)**2+semiperimeter**2)
    };
}

// Function to calculate the mixtilinear incircle (for 2nd point B in points) which is tangent to two of its sides (AB and BC)
// and internally tangent to its circumcircle.
function calculateMixtilinearIncircle(points) {
    const [A, B, C] = points;
    const incenter = calculateIncenter(points);
    const lineBI = [B, incenter];
    const slopeAB = calculateSlope(A, B);
    const slopeBC = calculateSlope(B, C);
    const verticalSlopeToLineBI = perpendicularSlope(calculateSlope(...lineBI));
    const verticalToSlopeAB = perpendicularSlope(slopeAB);
    const verticalToSlopeBC = perpendicularSlope(slopeBC);
    const D = lineIntersectionGivenSlopesAndPoints(slopeAB, B, verticalSlopeToLineBI, incenter);
    const E = lineIntersectionGivenSlopesAndPoints(slopeBC, B, verticalSlopeToLineBI, incenter);
    const center = lineIntersectionGivenSlopesAndPoints(verticalToSlopeAB, D, verticalToSlopeBC, E);
    return {
        center: center,
        radius: calculateDistance(D, center) 
    };
}

// Function to calculate the mixtilinear incircles
function calculateMixtilinearIncircles(points) {
    const [A, B, C] = points;
    return[
        calculateMixtilinearIncircle([C, A, B]),  // A-mixtilinear incircle
        calculateMixtilinearIncircle([A, B, C]),  // B-mixtilinear incircle
        calculateMixtilinearIncircle([B, C, A])   // C-mixtilinear incircle
    ];
}

// Function to calculate the three externally tangent circles centered at its vertices
function calculateThreeExternallyTangentCircles(points) {
    const [A, B, C] = points;
    const a = calculateDistance(B, C);
    const b = calculateDistance(C, A);
    const c = calculateDistance(A, B);
    const semiperimeter = (a + b + c) / 2;
    const circleA = {center: A, radius: semiperimeter - a};
    const circleB = {center: B, radius: semiperimeter - b};
    const circleC = {center: C, radius: semiperimeter - c};
    return [circleA, circleB, circleC];
}

// Function to calculate the medial triangles
function calculateMedialTriangle(points) {
    const [A, B, C] = points;

    return [
        midpoint(B, C),
        midpoint(C, A),
        midpoint(A, B)
    ];
}

// Function to calculate the excentral triangles
function calculateExcentralTriangle(points) {
    const [A, B, C] = points;
    return [
        calculateExcenter([C, A, B]),
        calculateExcenter([A, B, C]),
        calculateExcenter([B, C, A])
    ];
}

// Function to calculate the orthic triangles
function calculateOrthicTriangle(points) {
    const [A, B, C] = points;
    if (useHomogeneousCoordinates){
        const cosA = calculateCosine(C, A, B);
        const cosB = calculateCosine(A, B, C);
        const cosC = calculateCosine(B, C, A);
        return [
            trilinearToCartesian(points, [0, 1/cosB, 1/cosC]),
            trilinearToCartesian(points, [1/cosA, 0, 1/cosC]),
            trilinearToCartesian(points, [1/cosA, 1/cosB, 0]),
        ];
    }
    const slopeAB = calculateSlope(A, B);
    const slopeBC = calculateSlope(B, C);
    const slopeCA = calculateSlope(C, A);
    const perpendicularSlopeAB = perpendicularSlope(slopeAB);
    const perpendicularSlopeBC = perpendicularSlope(slopeBC);
    const perpendicularSlopeCA = perpendicularSlope(slopeCA);
    return [
        lineIntersectionGivenSlopesAndPoints(slopeBC, B, perpendicularSlopeBC, A),
        lineIntersectionGivenSlopesAndPoints(slopeCA, C, perpendicularSlopeCA, B),
        lineIntersectionGivenSlopesAndPoints(slopeAB, A, perpendicularSlopeAB, C)
    ];
}


// Function to calculate the reflection triangles
function calculateReflectionTriangle(points) {
    const [A, B, C] = points;
    if (useHomogeneousCoordinates){
        const cosA = calculateCosine(C, A, B);
        const cosB = calculateCosine(A, B, C);
        const cosC = calculateCosine(B, C, A);
        return [
            trilinearToCartesian(points, [-1, 2*cosC, 2*cosB]),
            trilinearToCartesian(points, [2*cosC, -1, 2*cosA]),
            trilinearToCartesian(points, [2*cosB, 2*cosA, -1]),
        ];
    }
    return [
        reflectPointAcrossLine(A, [B, C]),
        reflectPointAcrossLine(B, [C, A]),
        reflectPointAcrossLine(C, [A, B])
    ];
}

// Function to calculate the tangential triangle
function calculateTangentialTriangle(points) {
    if (isRightTriangle(points)) {
        return null;
    }
    const [A, B, C] = points;
    const [esA, esB, esC] = calculateExsymmedians(points);
    return [
        lineIntersection(...esB, ...esC),
        lineIntersection(...esC, ...esA),
        lineIntersection(...esA, ...esB),
    ];
}

// Function to calculate the anticomplementary triangles
function calculateAnticomplementaryTriangle(points) {
    const [A, B, C] = points;
    const centroid = calculateCentroid(points);
    return [
        {
            x: 3 * centroid.x - 2 * A.x,
            y: 3 * centroid.y - 2 * A.y,
        },
        {
            x: 3 * centroid.x - 2 * B.x,
            y: 3 * centroid.y - 2 * B.y,
        },
        {
            x: 3 * centroid.x - 2 * C.x,
            y: 3 * centroid.y - 2 * C.y,
        },
    ];
}

// Function to calculate the Cevian triangle
function calculateCevianTriangle(points, p) {
    const [A, B, C] = points;
    return [
        lineIntersection(A, p, B, C),
        lineIntersection(B, p, C, A),
        lineIntersection(C, p, A, B)
    ];
}


// Function to calculate the circumcevian triangle
function calculateCircumcevianTriangle(points, p) {
    const [A, B, C] = points;
    const circumcircle = calculateCircumcircle(points);
    let p1, p2;
    [p1, p2] = calculateIntersectionOfCircleAndLine(circumcircle, [A, p]);
    const pA = calculateDistance(p1, A) > calculateDistance (p2, A) ? p1 : p2;
    [p1, p2] = calculateIntersectionOfCircleAndLine(circumcircle, [B, p]);
    const pB = calculateDistance(p1, B) > calculateDistance (p2, B) ? p1 : p2;
    [p1, p2] = calculateIntersectionOfCircleAndLine(circumcircle, [C, p]);
    const pC = calculateDistance(p1, C) > calculateDistance (p2, C) ? p1 : p2;
    return [pA, pB, pC];
}

// Function to calculate the circum-medial triangle
function calculateCircumMedialTriangle(points) {
    if (useHomogeneousCoordinates) {
        const [A, B, C] = points;
        const a = calculateDistance(B, C);
        const b = calculateDistance(C, A);
        const c = calculateDistance(A, B);
        return [
            trilinearToCartesian(points, [-a*b*c, c*(b**2+c**2), b*(b**2+c**2)]),
            trilinearToCartesian(points, [c*(c**2+a**2), -a*b*c, a*(c**2+a**2)]),
            trilinearToCartesian(points, [b*(a**2+b**2), a*(a**2+b**2), -a*b*c])
        ];
    }
    const centroid = calculateCentroid(points);
    return calculateCircumcevianTriangle(points, centroid);
}

// Function to calculate the outer Napoleon triangle
function calculateNapoleonTriangle(points, outer = true) {
    const [A, B, C] = points;

    // Calculate the outer equilateral triangle on each side
    const isCounterclockwise =  isCounterclockwiseOrder(points);
    let rotationRadian = isCounterclockwise ? 60 : -60;
    rotationRadian = outer ? rotationRadian : -rotationRadian;

    // Create equilateral triangles on each side
    const R1 = rotate(B, A, rotationRadian);
    const R2 = rotate(C, B, rotationRadian);
    const R3 = rotate(A, C, rotationRadian);

    // Return the points of the outer Napoleon triangle
    return [
        calculateCentroid([B, C, R2]),
        calculateCentroid([C, A, R3]),
        calculateCentroid([A, B, R1])
    ];
}

// Function to calculate the intouch triangle
function calculateIntouchTriangle(points) {
    const [A, B, C] = points;

    if (useHomogeneousCoordinates) {
        const a = calculateDistance(B, C);
        const b = calculateDistance(C, A);
        const c = calculateDistance(A, B);
        return [
            trilinearToCartesian(points, [0, c*a/(a-b+c), a*b/(a+b-c)]),
            trilinearToCartesian(points, [b*c/(-a+b+c), 0, a*b/(a+b-c)]),
            trilinearToCartesian(points, [b*c/(-a+b+c), c*a/(a-b+c), 0])
        ];
    }

    const incenter = calculateIncenter(points);
    const slopeAB = calculateSlope(A, B);
    const slopeBC = calculateSlope(B, C);
    const slopeCA = calculateSlope(C, A);
    const perpendicularSlopeAB = perpendicularSlope(slopeAB);
    const perpendicularSlopeBC = perpendicularSlope(slopeBC);
    const perpendicularSlopeCA = perpendicularSlope(slopeCA);
    return [
        lineIntersectionGivenSlopesAndPoints(slopeBC, B, perpendicularSlopeBC, incenter),
        lineIntersectionGivenSlopesAndPoints(slopeCA, C, perpendicularSlopeCA, incenter),
        lineIntersectionGivenSlopesAndPoints(slopeAB, A, perpendicularSlopeAB, incenter)
    ];
}


// Function to calculate the extouch triangle
function calculateExtouchTriangle(points) {
    const [A, B, C] = points;
    const excenterA = calculateExcenter([C, A, B]);
    const excenterB = calculateExcenter([A, B, C]);
    const excenterC = calculateExcenter([B, C, A]);

    // Slopes of perpendicular bisectors
    const slopeAB = calculateSlope(A, B);
    const slopeBC = calculateSlope(B, C);
    const slopeCA = calculateSlope(C, A);
    const perpendicularSlopeAB = perpendicularSlope(slopeAB);
    const perpendicularSlopeBC = perpendicularSlope(slopeBC);
    const perpendicularSlopeCA = perpendicularSlope(slopeCA);

    return [
        lineIntersectionGivenSlopesAndPoints(slopeBC, B, perpendicularSlopeBC, excenterA),
        lineIntersectionGivenSlopesAndPoints(slopeCA, C, perpendicularSlopeCA, excenterB),
        lineIntersectionGivenSlopesAndPoints(slopeAB, A, perpendicularSlopeAB, excenterC)
    ];
}

// Function to calculate the Fuhrmann triangle
function calculateFuhrmannTriangle(points) {
    // Function to calculate point bisecting the arc AC length opposite to the points B
    function calculatePointBisectingArc(points) {
        const [A, B, C] = points;
        const circumcircle = calculateCircumcircle(points);
        const circumcenter = circumcircle.center;
        const circumradius = circumcircle.radius;
        const crossProductBA_BC = calculateCrossProduct(B, A, C);
        const perpendicularSlopeCA = perpendicularSlope(calculateSlope(C, A));
        const sqrtDenominator = Math.sqrt(perpendicularSlopeCA**2 + 1);
        // Two candidate points to bisect the arc length P1, P2
        const P1 = {
            x: circumcenter.x + circumradius / sqrtDenominator,
            y: isFinite(perpendicularSlopeCA) ? 
            circumcenter.y + circumradius * perpendicularSlopeCA / sqrtDenominator
            : circumcenter.y + circumradius
        };
        const P2 = {
            x: circumcenter.x - circumradius / sqrtDenominator,
            y: isFinite(perpendicularSlopeCA) ? 
            circumcenter.y - circumradius * perpendicularSlopeCA / sqrtDenominator
            : circumcenter.y - circumradius
        };
        crossProductP1A_P1C = calculateCrossProduct(P1, A, C);
        return (crossProductBA_BC * crossProductP1A_P1C < 0) ? P1 : P2;
    }

    const [A, B, C] = points;
    const midpointAB = midpoint(A, B);
    const midpointBC = midpoint(B, C);
    const midpointCA = midpoint(C, A);
    const PA = calculatePointBisectingArc([C, A, B]);
    const PB = calculatePointBisectingArc([A, B, C]);
    const PC = calculatePointBisectingArc([B, C, A]);
    return [
        {
            x: 2 * midpointBC.x - PA.x,
            y: 2 * midpointBC.y - PA.y
        },
        {
            x: 2 * midpointCA.x - PB.x,
            y: 2 * midpointCA.y - PB.y
        },
        {
            x: 2 * midpointAB.x - PC.x,
            y: 2 * midpointAB.y - PC.y
        },

    ];
}


// Function to calculate the Feuerbach triangle
function calculateFeuerbachTriangle(points) {
    const [A, B, C] = points;
    const excircleA = calculateExcircle([C, A, B]);
    const excircleB = calculateExcircle([A, B, C]);
    const excircleC = calculateExcircle([B, C, A]);
    const ninePointCircle = calculateNinePointCircle(points);

    return [
        calculateTangencyPoint(ninePointCircle, excircleA),
        calculateTangencyPoint(ninePointCircle, excircleB),
        calculateTangencyPoint(ninePointCircle, excircleC)
    ];
}

// Function to calculate the Brocard triangle
function calculateBrocardTriangle(points, number = 1) {
    if (isEquilateralTriangle(points)) {
        return null;
    }
    const [A, B, C] = points;
    let triangle;
    if (useHomogeneousCoordinates){
        const a = calculateDistance(B, C);
        const b = calculateDistance(C, A);
        const c = calculateDistance(A, B);
        switch(number){
        case 1:
            triangle = [
                trilinearToCartesian(points, [a*b*c, c**3, b**3]),
                trilinearToCartesian(points, [c**3, a*b*c, a**3]),
                trilinearToCartesian(points, [b**3, a**3, a*b*c])
            ];
            break;
        case 2:
            const cosA = calculateCosine(C, A, B);
            const cosB = calculateCosine(A, B, C);
            const cosC = calculateCosine(B, C, A);
            triangle = [
                trilinearToCartesian(points, [2*b*c*cosA, a*b, c*a]),
                trilinearToCartesian(points, [a*b, 2*c*a*cosB, b*c]),
                trilinearToCartesian(points, [c*a, b*c, 2*a*b*cosC])
            ];
            break;
        default:
            console.error(`Unknown number: ${number}`);
            return;
        }
        return triangle;
    }
    
    const firstBrocardPoint = calculateBrocardPoint(points, 1);
    const secondBrocardPoint = calculateBrocardPoint(points, 2);
    const isCounterclockwise =  isCounterclockwiseOrder(points);

    switch(number){
        case 1:
            if (isCounterclockwise){
                triangle = [
                    lineIntersection(B, firstBrocardPoint, C, secondBrocardPoint),
                    lineIntersection(C, firstBrocardPoint, A, secondBrocardPoint),
                    lineIntersection(A, firstBrocardPoint, B, secondBrocardPoint)
                ];
            }
            else {
                triangle = [
                    lineIntersection(C, firstBrocardPoint, B, secondBrocardPoint),
                    lineIntersection(A, firstBrocardPoint, C, secondBrocardPoint),
                    lineIntersection(B, firstBrocardPoint, A, secondBrocardPoint)
                ];
            }
            break;
        case 2:
            if (isCounterclockwise){
                const circleA = calculateCircumcircle([B, C, firstBrocardPoint]);
                const circleB = calculateCircumcircle([C, A, firstBrocardPoint]);
                const circleC = calculateCircumcircle([A, B, firstBrocardPoint]);
                const circleAA = calculateCircumcircle([B, C, secondBrocardPoint]);
                const circleBB = calculateCircumcircle([C, A, secondBrocardPoint]);
                const circleCC = calculateCircumcircle([A, B, secondBrocardPoint]);
                let p1, p2;
                [p1, p2] = calculateIntersectionOfTwoCircles(circleB, circleCC);
                const pA = calculateDistance(p1, A) > calculateDistance(p2, A) ? p1 : p2;
                [p1, p2] = calculateIntersectionOfTwoCircles(circleC, circleAA);
                const pB = calculateDistance(p1, B) > calculateDistance(p2, B) ? p1 : p2;
                [p1, p2] = calculateIntersectionOfTwoCircles(circleA, circleBB);
                const pC = calculateDistance(p1, C) > calculateDistance(p2, C) ? p1 : p2;
                triangle = [pA, pB, pC];
            }
            else {
                const circleA = calculateCircumcircle([C, B, secondBrocardPoint]);
                const circleB = calculateCircumcircle([A, C, secondBrocardPoint]);
                const circleC = calculateCircumcircle([B, A, secondBrocardPoint]);
                const circleAA = calculateCircumcircle([C, B, firstBrocardPoint]);
                const circleBB = calculateCircumcircle([A, C, firstBrocardPoint]);
                const circleCC = calculateCircumcircle([B, A, firstBrocardPoint]);
                let p1, p2;
                [p1, p2] = calculateIntersectionOfTwoCircles(circleB, circleCC);
                const pA = calculateDistance(p1, A) > calculateDistance(p2, A) ? p1 : p2;
                [p1, p2] = calculateIntersectionOfTwoCircles(circleC, circleAA);
                const pB = calculateDistance(p1, B) > calculateDistance(p2, B) ? p1 : p2;
                [p1, p2] = calculateIntersectionOfTwoCircles(circleA, circleBB);
                const pC = calculateDistance(p1, C) > calculateDistance(p2, C) ? p1 : p2;
                triangle = [pA, pB, pC];
            }
            break;
        default:
            console.error(`Unknown number: ${number}`);
            return;
    }
    return triangle;
}

// Function to calculate the Vecten triangle
function calculateVectenTriangle(points, outer = true) {
    const [A, B, C] = points;

    if (useHomogeneousCoordinates) {
        const tempConst = outer ? 1 : -1;
        const cosA = calculateCosine(C, A, B);
        const cosB = calculateCosine(A, B, C);
        const cosC = calculateCosine(B, C, A);
        const sinA = calculateSine(C, A, B);
        const sinB = calculateSine(A, B, C);
        const sinC = calculateSine(B, C, A);
        const trilinearA = [-1*tempConst, sinC + tempConst*cosC, sinB + tempConst*cosB];
        const trilinearB = [sinC + tempConst*cosC, -1*tempConst, sinA + tempConst*cosA];
        const trilinearC = [sinB + tempConst*cosB, sinA + tempConst*cosA, -1*tempConst];
        return [
            trilinearToCartesian(points, trilinearA),
            trilinearToCartesian(points, trilinearB),
            trilinearToCartesian(points, trilinearC),
        ];
    }

    // Determine rotation direction based on cross products
    const isCounterclockwise =  isCounterclockwiseOrder(points);
    let rotationRadian90 = isCounterclockwise ? 90 : -90;
    rotationRadian90 = outer ? rotationRadian90 : -rotationRadian90;

    return [
        midpoint(rotate(C, B, rotationRadian90), C),
        midpoint(rotate(A, C, rotationRadian90), A),
        midpoint(rotate(B, A, rotationRadian90), B)
    ];

}

// Function to calculate the Ayme triangle
function calculateAymeTriangle(points) {
    const [A, B, C] = points;
    const circumcircle = calculateCircumcircle(points);
    const excircleA = calculateExcircle([points[2], points[0], points[1]]);
    const excircleB = calculateExcircle(points);
    const excircleC = calculateExcircle([points[1], points[2], points[0]]);
    const lineA = calculateIntersectionOfTwoCircles(circumcircle, excircleA);
    const lineB = calculateIntersectionOfTwoCircles(circumcircle, excircleB);
    const lineC = calculateIntersectionOfTwoCircles(circumcircle, excircleC);
    return [
        lineIntersection(lineB[0], lineB[1], lineC[0], lineC[1]),
        lineIntersection(lineC[0], lineC[1], lineA[0], lineA[1]),
        lineIntersection(lineA[0], lineA[1], lineB[0], lineB[1])
    ];
}


// Function to calculate the Steiner triangle
function calculateSteinerTriangle(points) {
    if (isEquilateralTriangle(points)) {
        return null;
    }
    const [A, B, C] = points;
    const SteinerPoint = calculateSteinerPoint(points);
    return calculateCevianTriangle(points, SteinerPoint);
}


// Function to calculate the Lemoine hexagon
function calculateLemoineHexagon(points, selfIntersecting = false) {
    const [A, B, C] = points;
    const symmedianPoint = calculateSymmedianPoint(points);
    const slopeAB = calculateSlope(A, B);
    const slopeBC = calculateSlope(B, C);
    const slopeCA = calculateSlope(C, A);
    const PAB = lineIntersectionGivenSlopesAndPoints(slopeAB, A, slopeBC, symmedianPoint);
    const PAC = lineIntersectionGivenSlopesAndPoints(slopeCA, C, slopeBC, symmedianPoint);
    const PBA = lineIntersectionGivenSlopesAndPoints(slopeAB, A, slopeCA, symmedianPoint);
    const PBC = lineIntersectionGivenSlopesAndPoints(slopeBC, B, slopeCA, symmedianPoint);
    const PCA = lineIntersectionGivenSlopesAndPoints(slopeCA, C, slopeAB, symmedianPoint);
    const PCB = lineIntersectionGivenSlopesAndPoints(slopeBC, B, slopeAB, symmedianPoint);
    if (selfIntersecting) {
        return [PAB, PCB, PCA, PBA, PBC, PAC];
    }
    else {
        return [PAB, PBA, PCA, PAC, PBC, PCB];
    }
}

// Function to calculate the Steiner inellipse
function calculateSteinerInellipse(points) {
    const [A, B, C] = points;
    const a = calculateDistance(B, C);
    const b = calculateDistance(C, A);
    const c = calculateDistance(A, B);
    const centroid = calculateCentroid(points);
    const Z = Math.sqrt(
        Math.pow(a, 4) + Math.pow(b, 4) + Math.pow(c, 4) - 
        (Math.pow(a, 2) * Math.pow(b, 2)) - 
        (Math.pow(b, 2) * Math.pow(c, 2)) - 
        (Math.pow(c, 2) * Math.pow(a, 2))
    );
    // Calculate the semi-major axis (largest axis) and semi-minor axis (smallest axis)
    const semiMajorAxisLength = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) + Math.pow(c, 2) + 2 * Z) / 6;
    const semiMinorAxisLength = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) + Math.pow(c, 2) - 2 * Z) / 6;
    const rotationRadian = calculateAngleInRadianWithXAxis(calculateOrthogonalRegressionLine(points));
    return {
        center: centroid,
        radiusX: semiMajorAxisLength,
        radiusY: semiMinorAxisLength,
        rotationRadian: rotationRadian
    };
}

// Function to calculate the Steiner circumellipse
function calculateSteinerCircumellipse(points) {
    const [A, B, C] = points;
    const a = calculateDistance(B, C);
    const b = calculateDistance(C, A);
    const c = calculateDistance(A, B);
    const centroid = calculateCentroid(points);
    const Z = Math.sqrt(
        Math.pow(a, 4) + Math.pow(b, 4) + Math.pow(c, 4) - 
        (Math.pow(a, 2) * Math.pow(b, 2)) - 
        (Math.pow(b, 2) * Math.pow(c, 2)) - 
        (Math.pow(c, 2) * Math.pow(a, 2))
    );
    // Calculate the semi-major axis (largest axis) and semi-minor axis (smallest axis)
    const semiMajorAxisLength = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) + Math.pow(c, 2) + 2 * Z) / 3;
    const semiMinorAxisLength = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) + Math.pow(c, 2) - 2 * Z) / 3;
    const rotationRadian = calculateAngleInRadianWithXAxis(calculateOrthogonalRegressionLine(points));
    return {
        center: centroid,
        radiusX: semiMajorAxisLength,
        radiusY: semiMinorAxisLength,
        rotationRadian: rotationRadian
    };
}

// Function to calculate the Lemoine inellipse
function calculateLemoineInellipse(points) {
    const [A, B, C] = points;
    const centroid = calculateCentroid(points);
    const symmedianPoint = calculateSymmedianPoint(points);
    const a = calculateDistance(B, C);
    const b = calculateDistance(C, A);
    const c = calculateDistance(A, B);
    const semiMajorAxisLength = Math.sqrt((-(a**2)+2*b**2+2*c**2)*(2*a**2+2*b**2-c**2)*(2*a**2-b**2+2*c**2))/6/(a**2+b**2+c**2);
    const semiMinorAxisLength = 2 * calculateArea(points) / Math.sqrt(3*(a**2+b**2+c**2));

    if (closeEnoughPoints(centroid, symmedianPoint)) {
        // When the triangle is equilateral triangle 
        return {
            center: centroid,
            radiusX: semiMajorAxisLength,
            radiusY: semiMinorAxisLength,
            rotationRadian: 0,
        }
    }
    else{
        const rotationRadian = calculateAngleInRadianWithXAxis([centroid, symmedianPoint]);
        return {
            center: midpoint(centroid, symmedianPoint),
            radiusX: semiMajorAxisLength,
            radiusY: semiMinorAxisLength,
            rotationRadian: rotationRadian
        };
    }
}


</script>
</body>
</html>
