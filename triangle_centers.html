<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Triangle Centers</title>
    <style>
        canvas {
            border: 1px solid black;
        }
        .info {
            margin-top: 10px;
        }
        .center-info {
            color: black; /* Default color */
        }
        .center-info.disabled {
            color: lightgray; /* Disabled state */
        }
        .line-info {
            color: black; /* Default color */
        }
        .line-info.disabled {
            color: lightgray; /* Disabled state */
        }
        .circle-info {
            color: black; /* Default color */
        }
        .circle-info.disabled {
            color: lightgray; /* Disabled state */
        }
        .triangle-info {
            color: black; /* Default color */
        }
        .triangle-info.disabled {
            color: lightgray; /* Disabled state */
        }
    </style>
</head>
<body>

<h2>Triangle Centers</h2>

<!-- Drawing area -->
<canvas id="triangleCanvas"></canvas>

<!-- Information display -->
<div class="info">
    <p>Side lengths: AB = <span id="ab-length"></span>, BC = <span id="bc-length"></span>, CA = <span id="ca-length"></span></p>
    <p>Angles: ∠A = <span id="a-angle"></span>, ∠B = <span id="b-angle"></span>, ∠C = <span id="c-angle"></span></p>
    <p>Area: <span id="area"></span></p>
    <p>
        <button id="uncheck-all-btn">Uncheck all checkboxes</button>
    </p>
    <p>Points and centers</p>
    <div id="centers-section"></div>
    <p>Lines</p>
    <div id="lines-section"></div>
    <p>Circles</p>
    <div id="circles-section"></div>
    <p>Triangles</p>
    <div id="triangles-section"></div>
</div>

<script>
// Define styles for centers
// ETCReference is the reference number of the encyclopedia of triangle centers (ETC)
const centerStyles = {
    excenterA: {
        activeColor: 'orange',
        inactiveColor: 'lightgray', 
        checkboxId: 'excenterA-checkbox',
        displayElementId: 'excenterA',
        annotationLabel: 'Excenter (A)',
        informationText: '● Excenter opposite to vertex A',
    },
    excenterB: {
        activeColor: 'orange',
        inactiveColor: 'lightgray', 
        checkboxId: 'excenterB-checkbox',
        displayElementId: 'excenterB',
        annotationLabel: 'Excenter (B)',
        informationText: '● Excenter opposite to vertex B',
    },
    excenterC: {
        activeColor: 'orange',
        inactiveColor: 'lightgray', 
        checkboxId: 'excenterC-checkbox',
        displayElementId: 'excenterC',
        annotationLabel: 'Excenter (C)',
        informationText: '● Excenter opposite to vertex C',
    },
    incenter: {
        activeColor: 'green',
        inactiveColor: 'lightgray', 
        checkboxId: 'incenter-checkbox',
        displayElementId: 'incenter',
        annotationLabel: 'Incenter',
        informationText: '● Incenter',
        ETCReference: 1,
    },
    centroid: {
        activeColor: 'blue',
        inactiveColor: 'lightgray', 
        checkboxId: 'centroid-checkbox',
        displayElementId: 'centroid',
        annotationLabel: 'Centroid',
        informationText: '● Centroid',
        ETCReference: 2,
    },
    circumcenter: {
        activeColor: 'red',
        inactiveColor: 'lightgray', 
        checkboxId: 'circumcenter-checkbox',
        displayElementId: 'circumcenter',
        annotationLabel: 'Circumcenter',
        informationText: '● Circumcenter',
        ETCReference: 3,
    },
    orthocenter: {
        activeColor: 'purple',
        inactiveColor: 'lightgray', 
        checkboxId: 'orthocenter-checkbox',
        displayElementId: 'orthocenter',
        annotationLabel: 'Orthocenter',
        informationText: '● Orthocenter',
        ETCReference: 4,
    },
    ninePointCenter: {
        activeColor: 'lightblue',
        inactiveColor: 'lightgray', 
        checkboxId: 'ninePointCenter-checkbox',
        displayElementId: 'ninePointCenter',
        annotationLabel: 'Nine-point',
        informationText: '● Nine-point center',
        ETCReference: 5,
    },
    symmedianPoint: {
        activeColor: 'gold',
        inactiveColor: 'lightgray', 
        checkboxId: 'symmedianPoint-checkbox',
        displayElementId: 'symmedianPoint',
        annotationLabel: 'Symmedian',
        informationText: '● Symmedian point (Lemoine point, Grebe point)',
        ETCReference: 6,
    },
    GergonnePoint: {
        activeColor: 'brown',
        inactiveColor: 'lightgray', 
        checkboxId: 'GergonnePoint-checkbox',
        displayElementId: 'GergonnePoint',
        annotationLabel: 'Gergonne',
        informationText: '● Gergonne point',
        ETCReference: 7,
    },
    NagelPoint: {
        activeColor: 'red',
        inactiveColor: 'lightgray', 
        checkboxId: 'NagelPoint-checkbox',
        displayElementId: 'NagelPoint',
        annotationLabel: 'Nagel',
        informationText: '● Nagel point',
        ETCReference: 8,
    },
    Mittenpunkt: {
        activeColor: 'gray',
        inactiveColor: 'lightgray',
        checkboxId: 'Mittenpunkt-checkbox',
        displayElementId: 'Mittenpunkt',
        annotationLabel: 'Mittenpunkt',
        informationText: '● Mittenpunkt',
        ETCReference: 9,
    },
    SpiekerCenter: {
        activeColor: 'gray',
        inactiveColor: 'lightgray',
        checkboxId: 'SpiekerCenter-checkbox',
        displayElementId: 'SpiekerCenter',
        annotationLabel: 'Spieker',
        informationText: '● Spieker center',
        ETCReference: 10,
    },
    FeuerbachPoint: {
        activeColor: 'gray',
        inactiveColor: 'lightgray',
        checkboxId: 'FeuerbachPoint-checkbox',
        displayElementId: 'FeuerbachPoint',
        annotationLabel: 'Feuerbach',
        informationText: '● Feuerbach point',
        ETCReference: 11,
    },
    firstIsogonicCenter: {
        activeColor: 'gray',
        inactiveColor: 'lightgray', 
        checkboxId: 'firstIsogonicCenter-checkbox',
        displayElementId: 'firstIsogonicCenter',
        annotationLabel: '1st isogonic',
        informationText: '● First isogonic center',
        ETCReference: 13,
    },
    FermatPoint: {
        activeColor: 'gray',
        inactiveColor: 'lightgray', 
        checkboxId: 'FermatPoint-checkbox',
        displayElementId: 'FermatPoint',
        annotationLabel: 'Fermat',
        informationText: '● Fermat point',
        ETCReference: 13,
    },
    secondIsogonicCenter: {
        activeColor: 'gray',
        inactiveColor: 'lightgray', 
        checkboxId: 'secondIsogonicCenter-checkbox',
        displayElementId: 'secondIsogonicCenter',
        annotationLabel: '2nd isogonic',
        informationText: '● Second isogonic center',
        ETCReference: 14,
    },
    firstIsodynamicPoint: {
        activeColor: 'gray',
        inactiveColor: 'lightgray', 
        checkboxId: 'firstIsodynamicPoint-checkbox',
        displayElementId: 'firstIsodynamicPoint',
        annotationLabel: '1st isodynamic',
        informationText: '● First isodynamic point',
        ETCReference: 15,
    },
    secondIsodynamicPoint: {
        activeColor: 'gray',
        inactiveColor: 'lightgray', 
        checkboxId: 'secondIsodynamicPoint-checkbox',
        displayElementId: 'secondIsodynamicPoint',
        annotationLabel: '2nd isodynamic',
        informationText: '● Second isodynamic point',
        ETCReference: 16,
    },
    firstNapoleonPoint: {
        activeColor: 'brown',
        inactiveColor: 'lightgray', 
        checkboxId: 'firstNapoleonPoint-checkbox',
        displayElementId: 'firstNapoleonPoint',
        annotationLabel: '1st Napoleon',
        informationText: '● First Napoleon point',
        ETCReference: 17,
    },
    secondNapoleonPoint: {
        activeColor: '#c5956b',
        inactiveColor: 'lightgray', 
        checkboxId: 'secondNapoleonPoint-checkbox',
        displayElementId: 'secondNapoleonPoint',
        annotationLabel: '2nd Napoleon',
        informationText: '● Second Napoleon point',
        ETCReference: 18,
    },
    deLongchampsPoint: {
        activeColor: '#c54ea0',
        inactiveColor: 'lightgray', 
        checkboxId: 'deLongchampsPoint-checkbox',
        displayElementId: 'deLongchampsPoint',
        annotationLabel: 'de Longchamps',
        informationText: '● de Longchamps point',
        ETCReference: 20,
    },
    BevanPoint: {
        activeColor: 'gray',
        inactiveColor: 'lightgray',
        checkboxId: 'BevanPoint-checkbox',
        displayElementId: 'BevanPoint',
        annotationLabel: 'Bevan',
        informationText: '● Bevan point',
        ETCReference: 40,
    },
    FuhrmannCenter: {
        activeColor: 'gray',
        inactiveColor: 'lightgray',
        checkboxId: 'FuhrmannCenter-checkbox',
        displayElementId: 'FuhrmannCenter',
        annotationLabel: 'Fuhrmann',
        informationText: '● Fuhrmann center',
        ETCReference: 355,
    },
    CenterOfTheLesterCircle: {
        activeColor: 'gold',
        inactiveColor: 'lightgray', 
        checkboxId: 'CenterOfTheLesterCircle-checkbox',
        displayElementId: 'CenterOfTheLesterCircle',
        annotationLabel: 'Center of the Lester circle',
        informationText: '● Center of the Lester circle',
        ETCReference: 1116,
    },
};

// Define styles for lines
const lineStyles = {
    medians: {
        activeColor: 'gray',
        inactiveColor: 'lightgray',
        checkboxId: 'medians-checkbox',
        displayElementId: 'medians',
        annotationLabel: 'Median',
        informationText: '- Medians',
    },
    perpendicularBisectors: {
        activeColor: 'gray',
        inactiveColor: 'lightgray',
        checkboxId: 'perpendicularBisectors-checkbox',
        displayElementId: 'perpendicularBisectors',
        annotationLabel: 'perpendicular bisector',
        informationText: '- Perpendicular bisectors',
    },
    internalAngleBisectors: {
        activeColor: 'gray',
        inactiveColor: 'lightgray',
        checkboxId: 'internalAngleBisectors-checkbox',
        displayElementId: 'internalAngleBisectors',
        annotationLabel: 'angle bisector',
        informationText: '- Internal angle bisectors',
    },
    altitudes: {
        activeColor: 'gray',
        inactiveColor: 'lightgray',
        checkboxId: ' altitudes-checkbox',
        displayElementId: ' altitudes',
        annotationLabel: 'Altitude',
        informationText: '- Altitudes',
    },
    symmedians: {
        activeColor: 'gray',
        inactiveColor: 'lightgray',
        checkboxId: 'symmedians-checkbox',
        displayElementId: 'symmedians',
        annotationLabel: 'Symmedian',
        informationText: '- Symmedians',
    },
    splitters: {
        activeColor: 'gray',
        inactiveColor: 'lightgray',
        checkboxId: 'splitters-checkbox',
        displayElementId: 'splitters',
        annotationLabel: 'Splitter',
        informationText: '- Splitters',
    },
    cleavers: {
        activeColor: 'gray',
        inactiveColor: 'lightgray',
        checkboxId: 'cleavers-checkbox',
        displayElementId: 'cleavers',
        annotationLabel: 'Cleaver',
        informationText: '- Cleavers',
    },
    EulerLine: {
        activeColor: 'blue',
        inactiveColor: 'lightgray',
        checkboxId: 'EulerLine-checkbox',
        displayElementId: 'EulerLine',
        annotationLabel: 'Euler',
        informationText: '- Euler line',
    },
    NagelLine: {
        activeColor: 'red',
        inactiveColor: 'lightgray',
        checkboxId: 'NagelLine-checkbox',
        displayElementId: 'NagelLine',
        annotationLabel: 'Nagel',
        informationText: '- Nagel line',
    },
    FermatAxis: {
        activeColor: 'gray',
        inactiveColor: 'lightgray',
        checkboxId: 'FermatAxis-checkbox',
        displayElementId: 'FermatAxis',
        annotationLabel: 'Fermat axis',
        informationText: '- Fermat axis',
    },
};

// Define styles for circles
const circleStyles = {
    excircleA: {
        activeColor: 'orange',
        inactiveColor: 'lightgray',
        checkboxId: 'excircleA-checkbox',
        displayElementId: 'excircleA',
        annotationLabel: 'Excircle (A)',
        informationText: '○ Excircle opposite to vertex A',
    },
    excircleB: {
        activeColor: 'orange',
        inactiveColor: 'lightgray',
        checkboxId: 'excircleB-checkbox',
        displayElementId: 'excircleB',
        annotationLabel: 'Excircle (B)',
        informationText: '○ Excircle opposite to vertex B',
    },
    excircleC: {
        activeColor: 'orange',
        inactiveColor: 'lightgray',
        checkboxId: 'excircleC-checkbox',
        displayElementId: 'excircleC',
        annotationLabel: 'Excircle (C)',
        informationText: '○ Excircle opposite to vertex C',
    },
    incircle: {
        activeColor: 'green',
        inactiveColor: 'lightgray',
        checkboxId: 'incircle-checkbox',
        displayElementId: 'incircle',
        annotationLabel: 'Incircle',
        informationText: '○ Incircle',
    },
    circumcircle: {
        activeColor: 'red',
        inactiveColor: 'lightgray',
        checkboxId: 'circumcircle-checkbox',
        displayElementId: 'circumcircle',
        annotationLabel: 'Circumcircle',
        informationText: '○ Circumcircle',
    },
    ninePointCircle: {
        activeColor: 'lightblue',
        inactiveColor: 'lightgray',
        checkboxId: 'ninePointCircle-checkbox',
        displayElementId: 'ninePointCircle',
        annotationLabel: 'Nine-point',
        informationText: '○ Nine-point circle',
    },
    smallestCircle: {
        activeColor: 'gray',
        inactiveColor: 'lightgray',
        checkboxId: 'smallestCircle-checkbox',
        displayElementId: 'smallestCircle',
        annotationLabel: 'Smallest-circle',
        informationText: '○ Smallest-circle that contains all vertices of the triangle',
    },
    LesterCircle: {
        activeColor: 'gold',
        inactiveColor: 'lightgray',
        checkboxId: 'LesterCircle-checkbox',
        displayElementId: 'LesterCircle',
        annotationLabel: 'Lester',
        informationText: '○ Lester circle',
    },
    BevanCircle: {
        activeColor: 'gray',
        inactiveColor: 'lightgray',
        checkboxId: 'BevanCircle-checkbox',
        displayElementId: 'BevanCircle',
        annotationLabel: 'Bevan',
        informationText: '○ Bevan circle',
    },
    SpiekerCircle: {
        activeColor: 'gray',
        inactiveColor: 'lightgray',
        checkboxId: 'SpiekerCircle-checkbox',
        displayElementId: 'SpiekerCircle',
        annotationLabel: 'Spieker',
        informationText: '○ Spieker circle',
    },
    AdamsCircle: {
        activeColor: 'gray',
        inactiveColor: 'lightgray',
        checkboxId: 'AdamsCircle-checkbox',
        displayElementId: 'AdamsCircle',
        annotationLabel: 'Adams\'',
        informationText: '○ Adams\' circle',
    },
    AdamsCircle: {
        activeColor: 'gray',
        inactiveColor: 'lightgray',
        checkboxId: 'AdamsCircle-checkbox',
        displayElementId: 'AdamsCircle',
        annotationLabel: 'Adams\'',
        informationText: '○ Adams\' circle',
    },
    FuhrmannCircle: {
        activeColor: 'gray',
        inactiveColor: 'lightgray',
        checkboxId: 'FuhrmannCircle-checkbox',
        displayElementId: 'FuhrmannCircle',
        annotationLabel: 'Fuhrmann',
        informationText: '○ Fuhrmann circle',
    },
    MandartCircle: {
        activeColor: 'gray',
        inactiveColor: 'lightgray',
        checkboxId: 'MandartCircle-checkbox',
        displayElementId: 'MandartCircle',
        annotationLabel: 'Mandart',
        informationText: '○ Mandart circle',
    },
    MalfattiCircles: {
        activeColor: 'gray',
        inactiveColor: 'lightgray',
        checkboxId: 'MalfattiCircles-checkbox',
        displayElementId: 'MalfattiCircles',
        annotationLabel: 'Malfatti',
        informationText: '○ Malfatti circles',
    },
};

// Define styles for triangles
const triangleStyles = {
    medialTriangle: {
        activeColor: 'brown',
        inactiveColor: 'lightgray',
        checkboxId: 'medialTriangle-checkbox',
        displayElementId: 'medialTriangle',
        annotationLabel: 'Medial',
        informationText: '△ Medial triangle',
    },
    excentralTriangle: {
        activeColor: 'gray',
        inactiveColor: 'lightgray',
        checkboxId: 'excentralTriangle-checkbox',
        displayElementId: 'excentralTriangle',
        annotationLabel: 'Excentral',
        informationText: '△ Excentral triangle',
    },
    orthicTriangle: {
        activeColor: 'gray',
        inactiveColor: 'lightgray',
        checkboxId: 'orthicTriangle-checkbox',
        displayElementId: 'orthicTriangle',
        annotationLabel: 'Orthic',
        informationText: '△ Orthic triangle',
    },
    outerNapoleonTriangle: {
        activeColor: 'brown',
        inactiveColor: 'lightgray',
        checkboxId: 'outerNapoleonTriangle-checkbox',
        displayElementId: 'outerNapoleonTriangle',
        annotationLabel: 'Outer Napoleon',
        informationText: '△ Outer Napoleon triangle',
    },
    innerNapoleonTriangle: {
        activeColor: '#c5956b',
        inactiveColor: 'lightgray',
        checkboxId: 'innerNapoleonTriangle-checkbox',
        displayElementId: 'innerNapoleonTriangle',
        annotationLabel: 'Inner Napoleon',
        informationText: '△ Inner Napoleon triangle',
    },
    GergonneTriangle: {
        activeColor: 'brown',
        inactiveColor: 'lightgray',
        checkboxId: 'GergonneTriangle-checkbox',
        displayElementId: 'GergonneTriangle',
        annotationLabel: 'Gergonne',
        informationText: '△ Gergonne triangle',
    },
    extouchTriangle: {
        activeColor: 'brown',
        inactiveColor: 'lightgray',
        checkboxId: 'extouchTriangle-checkbox',
        displayElementId: 'extouchTriangle',
        annotationLabel: 'Extouch',
        informationText: '△ Extouch triangle',
    },
    FuhrmannTriangle: {
        activeColor: 'brown',
        inactiveColor: 'lightgray',
        checkboxId: 'FuhrmannTriangle-checkbox',
        displayElementId: 'FuhrmannTriangle',
        annotationLabel: 'Fuhrmann',
        informationText: '△ Fuhrmann triangle',
    },
    FeuerbachTriangle: {
        activeColor: 'brown',
        inactiveColor: 'lightgray',
        checkboxId: 'FeuerbachTriangle-checkbox',
        displayElementId: 'FeuerbachTriangle',
        annotationLabel: 'Feuerbach',
        informationText: '△ Feuerbach triangle',
    },
};

// Triangle vertices
let points = [
    { x: 300, y: 100 }, // A
    { x: 200, y: 273.20508 }, // B
    { x: 400, y: 273.20508 }  // C
];

let selectedPoint = null;
const scaleFactor = 0.01; // Factor to scale down distances
const epsilon = 1e-6; // Small tolerance value

// Canvas and context for drawing
const CANVAS_WIDTH = 1000;
const CANVAS_HEIGHT = 500;
const canvas = document.getElementById('triangleCanvas');
const ctx = canvas.getContext('2d');

// Combine all styles into one array of style objects
const allStyles = [
    ...Object.values(centerStyles),
    ...Object.values(lineStyles),
    ...Object.values(circleStyles),
    ...Object.values(triangleStyles)
];
const allCheckboxIds = [
    ...Object.values(centerStyles).map(style => style.checkboxId),
    ...Object.values(lineStyles).map(style => style.checkboxId),
    ...Object.values(circleStyles).map(style => style.checkboxId),
    ...Object.values(triangleStyles).map(style => style.checkboxId)
];

// Initial drawing
initializeStyles();
reDraw();

// Function to initialize styles (run once at the start)
function initializeStyles() {
    // Set canvas width and height using the constants
    const canvas = document.getElementById('triangleCanvas');
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;

    allStyles.forEach(style => {
        const displayElement = document.getElementById(style.displayElementId); // Get the element
        // Update the display text using informationText
        if (style.informationText && displayElement) {
            displayElement.textContent = style.informationText;
        }
    });
    createCheckboxes(Object.values(centerStyles), 'centers-section', 'center-info');
    createCheckboxes(Object.values(lineStyles), 'lines-section', 'line-info');
    createCheckboxes(Object.values(circleStyles), 'circles-section', 'circle-info');
    createCheckboxes(Object.values(triangleStyles), 'triangles-section', 'triangle-info');

    // Default the checkboxes for the five significant centers
    const defaultTrueCheckboxes = [
        centerStyles.excenterA.checkboxId,
        centerStyles.excenterB.checkboxId,
        centerStyles.excenterC.checkboxId,
        centerStyles.incenter.checkboxId,
        centerStyles.centroid.checkboxId,
        centerStyles.circumcenter.checkboxId,
        centerStyles.orthocenter.checkboxId,
    ];

    defaultTrueCheckboxes.forEach(checkboxId => {
        const checkbox = document.getElementById(checkboxId);
        if (checkbox) {
            checkbox.checked = true;
        }
    });

}

// Function to redraw the canvas
function reDraw(){
    drawOriginalTriangle();
    drawCenters();
    drawLines();
    drawCircles();
    drawTriangles();
    updateInfo();
    applyStyles();
}

// Function to update the information display
function updateInfo() {
    const [A, B, C] = points;

    // Side lengths
    document.getElementById('ab-length').textContent = (calculateDistance(A, B) * scaleFactor).toFixed(2);
    document.getElementById('bc-length').textContent = (calculateDistance(B, C) * scaleFactor).toFixed(2);
    document.getElementById('ca-length').textContent = (calculateDistance(C, A) * scaleFactor).toFixed(2);

    // Angles
    document.getElementById('a-angle').textContent = calculateAngleInDegrees(B, A, C).toFixed(2);
    document.getElementById('b-angle').textContent = calculateAngleInDegrees(A, B, C).toFixed(2);
    document.getElementById('c-angle').textContent = calculateAngleInDegrees(A, C, B).toFixed(2);

    // Area
    document.getElementById('area').textContent = (calculateArea(points) * scaleFactor**2).toFixed(2);
}

// Function to apply styles based on checkbox state
function applyStyles() {
    allStyles.forEach(style => {
        const checkbox = document.getElementById(style.checkboxId);
        const displayElement = document.getElementById(style.displayElementId);

        if (checkbox && displayElement) {
            if (checkbox.checked) {
                displayElement.style.color = style.activeColor;
                displayElement.classList.remove('disabled');
            } else {
                displayElement.style.color = style.inactiveColor;
                displayElement.classList.add('disabled');
            }
        }
    });
}

// Function to create checkboxes and add them to the correct section
function createCheckboxes(styleList, sectionId, className) {
    const section = document.getElementById(sectionId);

    styleList.forEach(style => {
        const p = document.createElement('p');

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = style.checkboxId;
        checkbox.checked = false;

        const span = document.createElement('span');
        span.id = style.displayElementId;
        span.className = className;
        span.textContent = style.informationText;

        p.appendChild(checkbox);
        p.appendChild(span);
        section.appendChild(p);
    });
}

// Mouse events
canvas.addEventListener('mousedown', (e) => {
    const mouseX = e.offsetX;
    const mouseY = e.offsetY;
    selectedPoint = getSelectedPoint(mouseX, mouseY);
});

canvas.addEventListener('mousemove', (e) => {
    if (selectedPoint) {
        selectedPoint.x = e.offsetX;
        selectedPoint.y = e.offsetY;
        requestAnimationFrame(reDraw);
    }
});

canvas.addEventListener('mouseup', () => {
    selectedPoint = null;
});

// Function to check if a point is being dragged
function getSelectedPoint(mouseX, mouseY) {
    return points.find(point => {
        const dist = Math.sqrt((point.x - mouseX) ** 2 + (point.y - mouseY) ** 2);
        return dist < 10; // If within 10px, select the point
    });
}

// Touch events
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault(); // Prevent page scroll on touch start
    const touch = e.touches[0]; // First touch point
    const rect = canvas.getBoundingClientRect();
    const touchX = touch.clientX - rect.left;
    const touchY = touch.clientY - rect.top;
    selectedPoint = getSelectedPoint(touchX, touchY);
});

canvas.addEventListener('touchmove', (e) => {
    if (selectedPoint) {
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        selectedPoint.x = touch.clientX - rect.left;
        selectedPoint.y = touch.clientY - rect.top;
        requestAnimationFrame(reDraw); // Use requestAnimationFrame for smoother updates
    }
    e.preventDefault(); // Prevent scrolling while dragging
});

canvas.addEventListener('touchend', () => {
    selectedPoint = null;
});

// Event listeners for checkboxes
allCheckboxIds.forEach(id => {
    document.getElementById(id).addEventListener('change', () => {
        reDraw();
    });
});

// Event listener for unchecking all checkboxes
document.getElementById('uncheck-all-btn').addEventListener('click', () => {
    // Uncheck all checkboxes
    allCheckboxIds.forEach(id => {
        const checkbox = document.getElementById(id);
        if (checkbox) {
            checkbox.checked = false; // Set the checkbox to unchecked
        }
    });
    reDraw();
});

// Function to draw the original triangle
function drawOriginalTriangle() {
    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
    ctx.beginPath();
    ctx.strokeStyle = 'black'
    ctx.moveTo(points[0].x, points[0].y);
    ctx.lineTo(points[1].x, points[1].y);
    ctx.lineTo(points[2].x, points[2].y);
    ctx.closePath();
    ctx.stroke();

    // Draw vertices and labels
    points.forEach((point, index) => {
        drawPoint(point, ['A', 'B', 'C'][index]);
    });
}


// Draw centers or points based on checkbox states
function drawCenters() {
    Object.keys(centerStyles).forEach(key => {
        const style = centerStyles[key];
        const checkbox = document.getElementById(style.checkboxId);

        if (checkbox && checkbox.checked) {
            let center;

            // Switch statement to handle different center calculations
            switch (key) {
                case 'centroid':
                    center = calculateCentroid(points);
                    break;
                case 'circumcenter':
                    center = calculateCircumcenter(points);
                    break;
                case 'incenter':
                    center = calculateIncenter(points);
                    break;
                case 'orthocenter':
                    center = calculateOrthocenter(points);
                    break;
                case 'excenterA':
                    center = calculateExcenter([points[2], points[0], points[1]]);
                    break;
                case 'excenterB':
                    center = calculateExcenter(points);
                    break;
                case 'excenterC':
                    center = calculateExcenter([points[1], points[2], points[0]]);
                    break;
                case 'firstIsogonicCenter':
                    center = calculateIsogonicCenter(points, outer = true);
                    break;
                case 'FermatPoint':
                    center = calculateFermatPoint(points);
                    break;
                case 'secondIsogonicCenter':
                    center = calculateIsogonicCenter(points, outer = false);
                    break;
                case 'firstIsodynamicPoint':
                    center = calculateIsodynamicPoint(points, outer = false);
                    break;
                case 'secondIsodynamicPoint':
                    center = calculateIsodynamicPoint(points, outer = true);
                    break;
                case 'deLongchampsPoint':
                    center = calculateDeLongchampsPoint(points);
                    break;
                case 'ninePointCenter':
                    center = calculateNinePointCenter(points);
                    break;
                case 'firstNapoleonPoint':
                    center = calculateNapoleonPoint(points, outer = true);
                    break;
                case 'secondNapoleonPoint':
                    center = calculateNapoleonPoint(points, outer = false);
                    break;
                case 'symmedianPoint':
                    center = calculateSymmedianPoint(points);
                    break;
                case 'CenterOfTheLesterCircle':
                    center = calculateLesterCircle(points).center;
                    break;
                case 'GergonnePoint':
                    center = calculateGergonnePoint(points);
                    break;
                case 'NagelPoint':
                    center = calculateNagelPoint(points);
                    break;   
                case 'BevanPoint':
                    center = calculateBevanPoint(points);
                    break;
                case 'Mittenpunkt':
                    center = calculateMittenpunkt(points);
                    break;
                case 'SpiekerCenter':
                    center = calculateSpiekerCenter(points);
                    break;
                case 'FeuerbachPoint':
                    center = calculateFeuerbachPoint(points);
                    break;
                case 'FuhrmannCenter':
                    center = calculateFuhrmannCenter(points);
                    break; 
                default:
                    console.error(`Unknown center key: ${key}`);
                    return;
            }

            // Draw the center point if it was calculated
            if (center) {
                drawPoint(center, style.annotationLabel, style.activeColor);
            }
        }
    });
}

// Draw lines based on checkbox states
function drawLines() {
    Object.keys(lineStyles).forEach(key => {
        const style = lineStyles[key];
        const checkbox = document.getElementById(style.checkboxId);

        if (checkbox && checkbox.checked) {
            let lines = [];

            // Switch statement to handle different line calculations
            switch (key) {
                case 'medians':
                    lines.push(...calculateMedians(points));
                    break;  
                case 'perpendicularBisectors':
                    lines.push(...calculatePerpendicularBisectors(points));
                    break;                
                case 'internalAngleBisectors':
                    lines.push(...calculateInternalAngleBisectors(points));
                    break;
                case 'altitudes':
                    lines.push(...calculateAltitudes(points));
                    break;  
                case 'symmedians':
                    lines.push(...calculateSymmedians(points));
                    break;      
                case 'splitters':
                    lines.push(...calculateSplitters(points));
                    break;
                case 'cleavers':
                    lines.push(...calculateCleavers(points));
                    break;           
                case 'EulerLine':
                    lines.push(calculateEulerLine(points));
                    break;
                case 'NagelLine':
                    lines.push(calculateNagelLine(points));
                    break;
                case 'FermatAxis':
                    lines.push(calculateFermatAxis(points));
                    break;
                default:
                    console.error(`Unknown line key: ${key}`);
                    return;
            }
            // Draw
            lines.forEach(line => {
                if (line) {
                    drawLine(line, style.annotationLabel, style.activeColor);
                }
            });

        }
    });
}

// Draw circles based on checkbox states
function drawCircles() {
    Object.keys(circleStyles).forEach(key => {
        const style = circleStyles[key];
        const checkbox = document.getElementById(style.checkboxId);

        if (checkbox && checkbox.checked) {
            let circles = []; // Multiple circles can be stored here

            // Switch statement to handle different circle calculations
            switch (key) {
                case 'incircle':
                    circles.push(calculateIncircle(points)); // Add a single circle to the list
                    break;
                case 'circumcircle':
                    circles.push(calculateCircumcircle(points));
                    break;
                case 'excircleA':
                    circles.push(calculateExcircle([points[2], points[0], points[1]]));
                    break;
                case 'excircleB':
                    circles.push(calculateExcircle(points));
                    break;
                case 'excircleC':
                    circles.push(calculateExcircle([points[1], points[2], points[0]]));
                    break;
                case 'ninePointCircle':
                    circles.push(calculateNinePointCircle(points));
                    break;
                case 'smallestCircle':
                    circles.push(calculateSmallestCircle(points));
                    break;
                case 'LesterCircle':
                    circles.push(calculateLesterCircle(points));
                    break;
                case 'BevanCircle':
                    circles.push(calculateBevanCircle(points));
                    break;
                case 'SpiekerCircle':
                    circles.push(calculateSpiekerCircle(points));
                    break;
                case 'AdamsCircle':
                    circles.push(calculateAdamsCircle(points));
                    break;
                case 'FuhrmannCircle':
                    circles.push(calculateFuhrmannCircle(points));
                    break;
                case 'MandartCircle':
                    circles.push(calculateMandartCircle(points));
                    break;
                case 'MalfattiCircles':
                    circles.push(...calculateMalfattiCircles(points));
                    break;
                default:
                    console.error(`Unknown circle key: ${key}`);
                    return;
            }

            // Draw
            circles.forEach(circle => {
                if (circle) {
                    drawCircle(circle, style.annotationLabel, style.activeColor);
                }
            });
        }
    });
}


// Draw triangles based on checkbox states
function drawTriangles() {
    Object.keys(triangleStyles).forEach(key => {
        const style = triangleStyles[key];
        const checkbox = document.getElementById(style.checkboxId);
        
        if (checkbox && checkbox.checked) {
            let triangle;
            
            // Switch statement to handle different triangle calculations
            switch (key) {
                case 'medialTriangle':
                    triangle = calculateMedialTriangle(points);
                    break;
                case 'excentralTriangle':
                    triangle = calculateExcentralTriangle(points);
                    break;
                case 'orthicTriangle':
                    triangle = calculateOrthicTriangle(points);
                    break;
                case 'outerNapoleonTriangle':
                    triangle = calculateNapoleonTriangle(points, outer = true);
                    break;
                case 'innerNapoleonTriangle':
                    triangle = calculateNapoleonTriangle(points, outer = false);
                    break;
                case 'GergonneTriangle':
                    triangle = calculateGergonneTriangle(points);
                    break;
                case 'extouchTriangle':
                    triangle = calculateExtouchTriangle(points);
                    break;
                case 'FuhrmannTriangle':
                    triangle = calculateFuhrmannTriangle(points);
                    break;
                case 'FeuerbachTriangle':
                    triangle = calculateFeuerbachTriangle(points);
                    break;
                default:
                    console.error(`Unknown triangle key: ${key}`);
                    return;
            }

            // Draw
            if (triangle) {
                drawTriangle(triangle, style.annotationLabel, style.activeColor);
            }
        }
    });
}

// Function to draw a point and its label
function drawPoint(point, label = '', color = 'black') {
    ctx.beginPath();
    ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    
    // Draw the label near the point
    if (label){
        ctx.font = '16px Arial';
        ctx.fillStyle = color;
        ctx.fillText(label, point.x - 5, point.y + 20); // Adjust position for readability
    }
}

// Function to draw a line between two points within the canvas bounds
function drawLine(line, label = '', color = 'black') {
    const [point1, point2] = line;
    if (closeEnoughPoints(point1, point2)) {
        return null;
    }
    const slope = calculateSlope(point1, point2);

    // Function to calculate y for a given x using the equation y = slope * x + b
    function calculateY(x) {
        if (isFinite(slope)) {
            return slope * (x - point1.x) + point1.y;
        } else {
            return null; // Vertical line, no y value for a given x
        }
    }

    // Function to calculate x for a given y using the equation x = (y - b) / slope
    function calculateX(y) {
        if (isFinite(slope)) {
            return (y - point1.y) / slope + point1.x;
        } else {
            return point1.x; // Vertical line, x is constant
        }
    }

    // Find the intersection points of the line with the canvas bounds
    let points = [];

    // When the line is vertical
    if (!isFinite(slope)) {
        if (0 <= point1.x && point1.x <= CANVAS_WIDTH) {
            points.push({ x: point1.x, y: 0 });
            points.push({ x: point1.x, y: CANVAS_HEIGHT });
        }
    } else {
        // Check for intersection with the left (x = 0) and right (x = CANVAS_WIDTH) boundaries
        let yAtX0 = calculateY(0);
        if (0 <= yAtX0 && yAtX0 <= CANVAS_HEIGHT) {
            points.push({ x: 0, y: yAtX0 });
        }
        let yAtXMax = calculateY(CANVAS_WIDTH);
        if (0 <= yAtXMax && yAtXMax <= CANVAS_HEIGHT) {
            points.push({ x: CANVAS_WIDTH, y: yAtXMax });
        }

        // Check for intersection with the top (y = 0) and bottom (y = CANVAS_HEIGHT) boundaries
        let xAtY0 = calculateX(0);
        if (0 < xAtY0 && xAtY0 < CANVAS_WIDTH) {
            points.push({ x: xAtY0, y: 0 });
        }
        let xAtYMax = calculateX(CANVAS_HEIGHT);
        if (0 < xAtYMax && xAtYMax < CANVAS_WIDTH) {
            points.push({ x: xAtYMax, y: CANVAS_HEIGHT });
        }
    }


    // If we have exactly two points, draw the line segment
    if (points.length === 2) {
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        ctx.lineTo(points[1].x, points[1].y);
        ctx.strokeStyle = color;
        ctx.stroke();

        // Draw the label near the midpoint of the line
        if (label) {
            const midX = (points[0].x + points[1].x) / 2;
            const midY = (points[0].y + points[1].y) / 2;
            ctx.font = '16px Arial';
            ctx.fillStyle = color;
            ctx.fillText(label, midX - 5, midY - 10); // Adjust position for readability
        }
    }
}


// Function to draw a circle
function drawCircle(circle, label = '', color = 'black') {
    ctx.beginPath();
    ctx.arc(circle.center.x, circle.center.y, circle.radius, 0, Math.PI * 2); // Draw a full circle
    ctx.strokeStyle = color;
    ctx.stroke();
    if (label){
        ctx.fillStyle = color;
        ctx.fillText(label, circle.center.x, circle.center.y + circle.radius + 15);
    }
}

// Function to draw a triangle
function drawTriangle(triangle, label = '', color = 'black') {
    const [A, B, C] = triangle;

    // Draw the triangle
    ctx.beginPath();
    ctx.moveTo(A.x, A.y);
    ctx.lineTo(B.x, B.y);
    ctx.lineTo(C.x, C.y);
    ctx.closePath();
    ctx.strokeStyle = color;
    ctx.stroke();

    // Draw the label at the centroid of the triangle (or near one vertex)
    if (label) {
        const centroidX = (A.x + B.x + C.x) / 3;
        const centroidY = (A.y + B.y + C.y) / 3;
        ctx.fillStyle = color;
        ctx.fillText(label, centroidX, centroidY);
    }
}


// Function to calculate the distance between two points
function calculateDistance(p1, p2) {
    return Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
}

// Function to calculate the angle (radian) at the middle point (B) given three points A, B, and C.
function calculateAngleInRadians(p1, p2, p3) {
    const v21 = vectorSubtract(p1, p2);
    const v23 = vectorSubtract(p3, p2);
    const cosTheta = dotProduct(v21, v23) / (magnitude(v21) * (magnitude(v23)));
    return Math.acos(cosTheta);
}

// Function to calculate the angle (degree) at the middle point (B) given three points A, B, and C.
function calculateAngleInDegrees(p1, p2, p3) {
    const thetaRad = calculateAngleInRadians(p1, p2, p3);
    return thetaRad * (180 / Math.PI);
}

// Function to calculate the area of the triangle
function calculateArea(points) {
    const [A, B, C] = points;
    return Math.abs((A.x * (B.y - C.y) + B.x * (C.y - A.y) + C.x * (A.y - B.y))) / 2;
}

function vectorSubtract(p1, p2) {
    return { x: p1.x - p2.x, y: p1.y - p2.y };
}

function dotProduct(v1, v2) {
    return v1.x * v2.x + v1.y * v2.y;
}

function magnitude(v) {
    return Math.sqrt(v.x * v.x + v.y * v.y);
}

function calculateSlope(p1, p2) {
    return (p2.y - p1.y) / (p2.x - p1.x)
}

function midpoint(p1, p2){
    return {
        x: (p1.x + p2.x) / 2,
        y: (p1.y + p2.y) / 2
    }
}

// Cross product of vectors p1p2 and p1p3
function calculateCrossProduct(p1, p2, p3) {
    return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);
}

function closeEnoughScalars(val1, val2) {
    return Math.abs(val1 - val2) < epsilon;
}

function closeEnoughPoints(p1, p2) {
    return calculateDistance(p1, p2) < epsilon;
}

function closeEnoughCircles(c1, c2) {
    return closeEnoughPoints(c1.center, c2.center) && closeEnoughScalars(c1.radius, c2.radius);
}

// Check if a triangle is equilateral
function isEquilateralTriangle(points) {
    const [A, B, C] = points;
    // Calculate the lengths of the sides of the triangle
    const a = calculateDistance(B, C); // Length of side BC
    const b = calculateDistance(A, C); // Length of side CA
    const c = calculateDistance(A, B); // Length of side AB
    
    // Check if all sides are approximately equal
    return closeEnoughScalars(a, b) && closeEnoughScalars(b, c);
}

// Check if a triangle is scalene
function isScaleneTriangle(points) {
    const [A, B, C] = points;
    const a = calculateDistance(B, C); // Length of side BC
    const b = calculateDistance(A, C); // Length of side CA
    const c = calculateDistance(A, B); // Length of side AB
    return !closeEnoughScalars(a, b) && !closeEnoughScalars(b, c) && !closeEnoughScalars(c, a);
}

function perpendicularSlope(slope) {
    // Handle cases where slopes might be 0 or undefined (vertical or horizontal lines)
    if (slope === 0) {
        return Infinity; // slope is horizontal, perpendicular is vertical
    } else if (!isFinite(slope)) {
        return 0; // slope is vertical, perpendicular is horizontal
    } else {
        return -1 / slope;
    }
}

// Function to rotate a point P around another point O by d degrees
// Be careful to consider the coordinates in canvas environment
function rotate(P, O, d) {
    const radian = Math.PI*d / 180;
    const dx = P.x - O.x;
    const dy = P.y - O.y;
    return {
        x: O.x + (dx * Math.cos(radian) - dy * Math.sin(radian)),
        y: O.y + (dx * Math.sin(radian) + dy * Math.cos(radian))
    };
}

/**
 * Function to reflect a point across a line segment.
 * Parameters;
 * point - The point to reflect, with properties x and y.
 * linePoints - An array of two points, each with properties x and y, representing the line segment.
 * Returns;
 * The reflected point with properties x and y.
 */
 function reflectPointAcrossLine(point, line) {
    const [p1, p2] = line;
    const slope = calculateSlope(p1, p2);

    // If the line is vertical
    if (!isFinite(slope)) {
        return {
            x: 2 * p1.x - point.x,
            y: point.y
        };
    }

    // If the line is horizontal
    if (slope === 0) {
        return {
            x: point.x,
            y: 2 * p1.y - point.y
        };
    }

    const intercept = p1.y - slope * p1.x;
    const perSlope = perpendicularSlope(slope);
    
    // Calculate the intersection of the line through the point and perpendicular to the given line
    const intersection = lineIntersectionGivenSlopesAndPoints(slope, p1, perSlope, point);
    return {
        x: 2 * intersection.x - point.x,
        y: 2 * intersection.y - point.y
    };
}

// Function to find the intersection of two lines (P1, P2) and (Q1, Q2)
function lineIntersection(P1, P2, Q1, Q2) {
    const a1 = P2.y - P1.y;
    const b1 = P1.x - P2.x;
    const c1 = a1 * P1.x + b1 * P1.y;

    const a2 = Q2.y - Q1.y;
    const b2 = Q1.x - Q2.x;
    const c2 = a2 * Q1.x + b2 * Q1.y;

    const determinant = a1 * b2 - a2 * b1;

    if (determinant === 0) {
        return null; // Parallel lines
    } else {
        const x = (b2 * c1 - b1 * c2) / determinant;
        const y = (a1 * c2 - a2 * c1) / determinant;
        return { x, y };
    }
}

/**
 * This function calculates the intersection point of two lines, given their slopes and a point on each line.
 * The equations of the lines are derived using the point-slope form of a line equation: 
 * (y - y1) = m(x - x1), where m is the slope and (x1, y1) is a point on the line.
 * 
 * Parameters:
 *  - slope1: The slope of the first line.
 *  - point1: An object representing a point {x, y} on the first line.
 *  - slope2: The slope of the second line.
 *  - point2: An object representing a point {x, y} on the second line.
 * 
 * Returns:
 *  - An object {x, y} representing the intersection point of the two lines.
 *  - If the lines are parallel (i.e., the slopes are the same), the function returns null.
 */
 function lineIntersectionGivenSlopesAndPoints(slope1, point1, slope2, point2) {
    // Check if the lines are parallel by comparing the slopes
    if (slope1 === slope2) {
        return null; // Parallel lines do not intersect
    } else if (!isFinite(slope1)) {
        // If the line1 is vertical
        const x = point1.x;
        const y = slope2 * (x - point2.x) + point2.y;
        return { x, y };
    } else if (!isFinite(slope2)) {
        // If the line2 is vertical
        const x = point2.x;
        const y = slope1 * (x - point1.x) + point1.y;
        return { x, y };
    } else {
        // Calculate the intersection point using the point-slope formula
        const x = (slope1 * point1.x - point1.y - slope2 * point2.x + point2.y) / (slope1 - slope2);
        const y = slope1 * (x - point1.x) + point1.y;
        return { x, y };
    }
}


// Function to calculate a tangency point between two circles
function calculateTangencyPoint(c1, c2) {
    if (closeEnoughCircles(c1, c2)) {
        return null;
    }
    slope = calculateSlope(c1.center, c2.center);
    let P1, P2;
    if (isFinite(slope)) {
        const coefficient = c1.radius / Math.sqrt(slope ** 2 + 1);
        P1 = {
            x: c1.center.x + coefficient,
            y: c1.center.y + slope * coefficient
        };
        P2 = {
            x: c1.center.x - coefficient,
            y: c1.center.y - slope * coefficient
        };
    }
    else{
        P1 = {
            x: c1.center.x,
            y: c1.center.y + c1.radius
        };
        P2 = {
            x: c1.center.x,
            y: c1.center.y - c1.radius
        };
    }
    if (closeEnoughScalars((P1.x - c2.center.x)**2 + (P1.y - c2.center.y)**2, c2.radius ** 2)) {
        return P1;
    }
    else {
        return P2;
    }
}

// Function to calculate the centroid of the triangle
function calculateCentroid(points) {
    const [A, B, C] = points;
    const x = ((A.x + B.x + C.x) / 3);
    const y = ((A.y + B.y + C.y) / 3);
    return { x, y };
}

// Function to calculate the circumcenter (intersection of perpendicular bisectors)
function calculateCircumcenter(points) {
    const [A, B, C] = points;

    // Midpoints of sides
    const D = { x: (A.x + B.x) / 2, y: (A.y + B.y) / 2 };
    const E = { x: (B.x + C.x) / 2, y: (B.y + C.y) / 2 };

    // Slopes of perpendicular bisectors
    const perpendicularSlopeAB = perpendicularSlope(calculateSlope(A, B));
    const perpendicularSlopeBC = perpendicularSlope(calculateSlope(B, C));

    // Circumcenter calculation
    return lineIntersectionGivenSlopesAndPoints(perpendicularSlopeAB, D, perpendicularSlopeBC, E);
}

// Function to calculate the incenter (intersection of angle bisectors)
function calculateIncenter(points) {
    const [A, B, C] = points;

    // Lengths of the sides
    const a = calculateDistance(B, C);
    const b = calculateDistance(A, C);
    const c = calculateDistance(A, B);

    // Incenter coordinates
    const x = (a * A.x + b * B.x + c * C.x) / (a + b + c);
    const y = (a * A.y + b * B.y + c * C.y) / (a + b + c);

    return { x, y };
}

// Function to calculate the orthocenter (intersection of perpendiculars)
function calculateOrthocenter(points) {
    const [A, B, C] = points;
    // Calculate perpendiculars
    const perpendicularSlopeAB = perpendicularSlope(calculateSlope(A, B));
    const perpendicularSlopeBC = perpendicularSlope(calculateSlope(B, C));

    // Solve for the intersection of the two perpendiculars (Orthocenter)
    return lineIntersectionGivenSlopesAndPoints(perpendicularSlopeAB, C, perpendicularSlopeBC, A);
}

// Function to calculate the excenter for the vertex B (intersection of the internal angle bisectors of the vertex and other external angle bisectors)
function calculateExcenter(points) {
    const [A, B, C] = points;
    // Lengths of the triangle sides opposite to each vertex
    const a =  calculateDistance(B, C); // Length of side BC
    const b =  calculateDistance(C, A); // Length of side CA
    const c =  calculateDistance(A, B); // Length of side AB

    // Excenter formula for vertex B (opposite to side AC)
    return {
        x: (-b * B.x + c * C.x + a * A.x) / (-b + c + a),
        y: (-b * B.y + c * C.y + a * A.y) / (-b + c + a)
    }
}

// Function to calculate the isogonic center
function calculateIsogonicCenter(points, outer = true) {
    const [A, B, C] = points;

    if (!outer){
        if (isEquilateralTriangle(points)){
            return null;
        } 
    }

    // Determine rotation direction based on the cross product of vectors AB and AC
    const crossProduct = calculateCrossProduct(A, B, C);
    let rotationRadian = crossProduct > 0 ? -60 : 60;
    if (!outer){
        rotationRadian = -rotationRadian;
    }

    // Calculate rotation points for Fermat point
    const R1 = rotate(B, A, rotationRadian); // Rotate B 60 degrees around A
    const R2 = rotate(C, A, -rotationRadian); // Rotate C 60 degrees around A

    // Intersection of lines BR2 and CR1 gives the Fermat point
    return lineIntersection(B, R2, C, R1);
}

// Function to calculate the isodynamic point
function calculateIsodynamicPoint(points, outer = false) {
    if (outer) {
        if (isEquilateralTriangle(points)){
            return null;
        }    
    }
    const [A, B, C] = points;

    // Determine rotation direction based on the cross product of vectors AB and AC
    const crossProduct = calculateCrossProduct(A, B, C);
    let rotationRadian = crossProduct > 0 ? -60 : 60;
    if (!outer){
        rotationRadian = -rotationRadian;
    }

    // Calculate rotation points for Fermat point
    const P1 = rotate(C, B, rotationRadian);
    const P2 = rotate(A, C, rotationRadian);
    const Q1 = reflectPointAcrossLine(A, [B, C]);
    const Q2 = reflectPointAcrossLine(B, [C, A]);

    // Intersection of lines BR2 and CR1 gives the Fermat point
    return lineIntersection(P1, Q1, P2, Q2);
}

// Function to calculate the isogonic center
function calculateFermatPoint(points) {
    const [A, B, C] = points;
    
    // Check for angles >= 120 degrees
    if (calculateAngleInDegrees(B, A, C) >= 120) {
        return A;
    } else if (calculateAngleInDegrees(A, B, C) >= 120) {
        return B;
    } else if (calculateAngleInDegrees(A, C, B) >= 120) {
        return C;
    }
    else{
        return calculateIsogonicCenter(points, outer = true);
    }
}


// Function to calculate the de Longchamps point that is the reflection of the orthocenter of the triangle about the circumcenter
function calculateDeLongchampsPoint(points) {
    const [A, B, C] = points;
    const orthocenter = calculateOrthocenter(points);
    const circumcenter = calculateCircumcenter(points);
    return {
        x: 2 * circumcenter.x - orthocenter.x,
        y: 2 * circumcenter.y - orthocenter.y,
    }
}

// Function to calculate the nine point center
function calculateNinePointCenter(points) {
    // Calculate the center and radius
    // The center is the midpoint between the orthocenter and circumcenter.
    // The radius is half of the circumradius.
    const orthocenter = calculateOrthocenter(points);
    const circumcircle = calculateCircumcircle(points);
    const circumcenter = circumcircle.center;
    return {
        x: (orthocenter.x + circumcenter.x)/2,
        y: (orthocenter.y + circumcenter.y)/2
    };
}

// Function to calculate the Napoleon points
function calculateNapoleonPoint(points, outer = true) {
    const [A, B, C] = points;
    const [D, E, F] = calculateNapoleonTriangle(points, outer = outer);
    return lineIntersection(A, D, B, E);
}

// Function to calculate the symmedian point
function calculateSymmedianPoint(points) {
    const [A, B, C] = points;
    // The circumcircle of triangle ABC and the tangents at each vertex.
    const circumcenter = calculateCircumcenter(points);
    const tangentSlopeA = perpendicularSlope(calculateSlope(circumcenter, A));
    const tangentSlopeB = perpendicularSlope(calculateSlope(circumcenter, B));
    const tangentSlopeC = perpendicularSlope(calculateSlope(circumcenter, C));
    // calculate symmedians
    const P1 = lineIntersectionGivenSlopesAndPoints(tangentSlopeB, B, tangentSlopeC, C);
    const P2 = lineIntersectionGivenSlopesAndPoints(tangentSlopeA, A, tangentSlopeC, C);
    return lineIntersection(A, P1, B, P2);
}


// Function to calculate the Gergonne point
function calculateGergonnePoint(points) {
    const GergonneTriangle = calculateGergonneTriangle(points);
    return lineIntersection(points[0], GergonneTriangle[0], points[1], GergonneTriangle[1]);
}

// Function to calculate the Nagel point
function calculateNagelPoint(points) {
    const extouchTriangle = calculateExtouchTriangle(points);
    return lineIntersection(points[0], extouchTriangle[0], points[1], extouchTriangle[1]);
}

// Function to calculate the Bevan point
function calculateBevanPoint(points) {
    return calculateBevanCircle(points).center;
}

// Function to calculate the Mittenpunkt
function calculateMittenpunkt(points) {
    const excentralTriangle = calculateExcentralTriangle(points);
    return calculateSymmedianPoint(excentralTriangle);
}

// Function to calculate the Spieker center
function calculateSpiekerCenter(points) {
    const medialTriangle = calculateMedialTriangle(points);
    return calculateIncenter(medialTriangle);
}

// Function to calculate the Feuerbach point
function calculateFeuerbachPoint(points) {
    const incircle = calculateIncircle(points);
    const ninePointCircle = calculateNinePointCircle(points);
    return calculateTangencyPoint(incircle, ninePointCircle);
}


// Function to calculate the Fuhrmann center
function calculateFuhrmannCenter(points) {
    return calculateCircumcircle(calculateFuhrmannTriangle(points)).center;
}

// Function to calculate the medians
function calculateMedians(points) {
    const [A, B, C] = points;
    const centroid = calculateCentroid(points);
    return [
        [A, centroid],
        [B, centroid],
        [C, centroid]
    ];
}

// Function to calculate the perpendicular bisectors
function calculatePerpendicularBisectors(points) {
    const [A, B, C] = points;
    const circumcenter = calculateCircumcenter(points);
    return [
        [midpoint(B, C), circumcenter],
        [midpoint(C, A), circumcenter],
        [midpoint(A, B), circumcenter]
    ];
}


// Function to calculate the internal angle bisectors
function calculateInternalAngleBisectors(points) {
    const [A, B, C] = points;
    const incenter = calculateIncenter(points);
    return [
        [A, incenter],
        [B, incenter],
        [C, incenter]
    ];
}

// Function to calculate the altitudes
function calculateAltitudes(points) {
    const [A, B, C] = points;
    const orthocenter = calculateOrthocenter(points);
    return [
        [A, orthocenter],
        [B, orthocenter],
        [C, orthocenter]
    ];
}

// Function to calculate the symmedians
function calculateSymmedians(points) {
    const [A, B, C] = points;
    const symmedianPoint = calculateSymmedianPoint(points);
    return [
        [A, symmedianPoint],
        [B, symmedianPoint],
        [C, symmedianPoint]
    ];
}

// Function to calculate the splitters
function calculateSplitters(points) {
    const [A, B, C] = points;
    const NagelPoint = calculateNagelPoint(points);
    return [
        [A, NagelPoint],
        [B, NagelPoint],
        [C, NagelPoint]
    ];
}

// Function to calculate the cleavers
function calculateCleavers(points) {
    const [A, B, C] = points;
    const SpiekerCenter = calculateSpiekerCenter(points);
    return [
        [midpoint(B, C), SpiekerCenter],
        [midpoint(C, A), SpiekerCenter],
        [midpoint(A, B), SpiekerCenter]
    ];
}


// Function to calculate the Euler line
function calculateEulerLine(points) {
    const orthocenter = calculateOrthocenter(points);
    const circumcenter = calculateCircumcenter(points);
    return [orthocenter, circumcenter];
}

// Function to calculate the Nagel line
function calculateNagelLine(points) {
    return [
        calculateIncenter(points),
        calculateNagelPoint(points)
    ];
}

// Function to calculate the Fermat axis
function calculateFermatAxis(points) {
    return[
        calculateIsogonicCenter(points, outer = true),
        calculateIsogonicCenter(points, outer = false)
    ];
}

// Function to calculate the incircle
function calculateIncircle(points) {
    const [A, B, C] = points;
    
    // Calculate the incenter (already defined)
    const incenter = calculateIncenter(points);

    // Calculate the radius of the incircle using the formula: 2 * area / (a + b + c)
    const a = calculateDistance(B, C);
    const b = calculateDistance(C, A);
    const c = calculateDistance(A, B);
    const area = calculateArea(points);
    const radius = 2 * area / (a + b + c);

    // Return the circle object with center and radius
    return {
        center: incenter,
        radius: radius
    };
}


// Function to calculate the circumcircle
function calculateCircumcircle(points) {
    const [A, B, C] = points;
    
    // Calculate the circumcenter (already defined)
    const center = calculateCircumcenter(points);

    // Calculate the circumradius using the formula R = (a * b * c) / (4 * area)
    const a = calculateDistance(B, C);
    const b = calculateDistance(A, C);
    const c = calculateDistance(A, B);
    const area = calculateArea(points);
    const radius = (a * b * c) / (4 * area);

    // Return the circle object with center and radius
    return {
        center: center,
        radius: radius
    };
}

// Function to calculate the excircle opposite to the vertex B
function calculateExcircle(points) {
    const [A, B, C] = points;

    // Calculate the radius using the formula: 2 * area / (-a + b + c)
    const a = calculateDistance(B, C);
    const b = calculateDistance(C, A);
    const c = calculateDistance(A, B);
    const area = calculateArea(points);

    return {
        center: calculateExcenter(points),
        radius: 2 * area / (-b + c + a)
    };
}

// Function to calculate the nine-point circle
function calculateNinePointCircle(points) {
    // Calculate the center and radius
    // The center is the midpoint between the orthocenter and circumcenter.
    // The radius is half of the circumradius.
    const circumcircle = calculateCircumcircle(points);

    // Return the circle object with center and radius
    return {
        center: calculateNinePointCenter(points),
        radius: circumcircle.radius / 2
    };
}

// Function to calculate the smallest circle that contains all vertices of the original triangle
function calculateSmallestCircle(points) {
    const [A, B, C] = points;
    const a = calculateDistance(B, C);
    const b = calculateDistance(C, A);
    const c = calculateDistance(A, B);
    if (b**2 + c**2 < a **2){ // when the angle A is obtuse 
        return{
            center: midpoint(B, C),
            radius: a / 2
        }
    }
    else if (a**2 + c**2 < b **2){ // when the angle B is obtuse 
        return{
            center: midpoint(A, C),
            radius: b / 2
        }
    }
    else if (a**2 + b**2 < c **2){ // when the angle C is obtuse 
        return{
            center: midpoint(A, B),
            radius: c / 2
        }
    }
    else{
        return calculateCircumcircle(points);
    }
}

// Function to calculate the Lester circle
function calculateLesterCircle(points) {
    const firstIsogonicCenter = calculateIsogonicCenter(points, outer = true);
    const secondIsogonicCenter = calculateIsogonicCenter(points, outer = false);
    const circumcenter = calculateCircumcenter(points);
    if (isScaleneTriangle(points)){
        // When the triangle is scalene
        return calculateCircumcircle([firstIsogonicCenter, secondIsogonicCenter, circumcenter]);
    }
    else{
        return null;
    }
}

// Function to calculate the Bevan circle
function calculateBevanCircle(points) {
    const excentralTriangle = calculateExcentralTriangle(points);
    return calculateCircumcircle(excentralTriangle);
}

// Function to calculate the Spieker circle
function calculateSpiekerCircle(points) {
    const medialTriangle = calculateMedialTriangle(points);
    return calculateIncircle(medialTriangle);
}

// Function to calculate the Adams' circle
function calculateAdamsCircle(points) {
    const [A, B, C] = points;
    const slopeAB = calculateSlope(A, B);
    const slopeBC = calculateSlope(B, C);
    const slopeCA = calculateSlope(C, A);
    const GergonnePoint = calculateGergonnePoint(points);
    const GergonneTriangle = calculateGergonneTriangle(points);
    const slopeGTAB = calculateSlope(GergonneTriangle[0], GergonneTriangle[1]);
    const slopeGTBC = calculateSlope(GergonneTriangle[1], GergonneTriangle[2]);
    P1 = lineIntersectionGivenSlopesAndPoints(slopeGTAB, GergonnePoint, slopeBC, B);
    P2 = lineIntersectionGivenSlopesAndPoints(slopeGTAB, GergonnePoint, slopeCA, C);
    P3 = lineIntersectionGivenSlopesAndPoints(slopeGTBC, GergonnePoint, slopeAB, A);
    return calculateCircumcircle([P1, P2, P3]);  
}

// Function to calculate the Fuhrmann circle
function calculateFuhrmannCircle(points) {
    return calculateCircumcircle(calculateFuhrmannTriangle(points));
}

// Function to calculate the Mandart circle
function calculateMandartCircle(points) {
    return calculateCircumcircle(calculateExtouchTriangle(points));
}

// Function to calculate the Malfatti circles
function calculateMalfattiCircles(points) {
    // Function to calculate the center of Malfatti circles near the vertex A
    function calculateCenters(points, P, r) {
        const [A, B, C] = points;
        const perpendicularSlopeAB = perpendicularSlope(calculateSlope(A, B));
        const sqrtDenominator = Math.sqrt(perpendicularSlopeAB**2 + 1);
        // Two candidates of centers
        const P1 = {
            x: P.x + r / sqrtDenominator,
            y: isFinite(perpendicularSlopeAB) ? 
            P.y + r * perpendicularSlopeAB / sqrtDenominator
            : P.y + r
        };
        const P2 = {
            x: P.x - r / sqrtDenominator,
            y: isFinite(perpendicularSlopeAB) ? 
            P.y - r * perpendicularSlopeAB / sqrtDenominator
            : P.y - r
        };
        return (calculateCrossProduct(A, B, C) * calculateCrossProduct(A, B, P1) >= 0) ? P1 : P2;
    }
    const [A, B, C] = points;
    const a = calculateDistance(B, C);
    const b = calculateDistance(C, A);
    const c = calculateDistance(A, B);
    const incircle = calculateIncircle(points);
    const inradius = incircle.radius;
    const incenter = incircle.center;
    const IA = calculateDistance(incenter, A);
    const IB = calculateDistance(incenter, B);
    const IC = calculateDistance(incenter, C);
    const semiperimeter = (a + b + c) / 2;
    const rA = inradius * (semiperimeter - inradius + IA - IB - IC) / 2 / (semiperimeter-a);
    const rB = inradius * (semiperimeter - inradius - IA + IB - IC) / 2 / (semiperimeter-b);
    const rC = inradius * (semiperimeter - inradius - IA - IB + IC) / 2 / (semiperimeter-c);
    const radianA = calculateAngleInRadians(C, A, B);
    const radianB = calculateAngleInRadians(A, B, C);
    const radianC = calculateAngleInRadians(B, C, A);
    const dA = rA / Math.tan(radianA / 2);
    const dB = rB / Math.tan(radianB / 2);
    const dC = rC / Math.tan(radianC / 2);
    const PA = {x: ((c-dA)*A.x+dA*B.x)/c, y: ((c-dA)*A.y+dA*B.y)/c};
    const PB = {x: ((a-dB)*B.x+dB*C.x)/a, y: ((a-dB)*B.y+dB*C.y)/a};
    const PC = {x: ((b-dC)*C.x+dC*A.x)/b, y: ((b-dC)*C.y+dC*A.y)/b};
    const circleA = {center: calculateCenters([A, B, C], PA, rA), radius: rA};
    const circleB = {center: calculateCenters([B, C, A], PB, rB), radius: rB};
    const circleC = {center: calculateCenters([C, A, B], PC, rC), radius: rC};
    return [circleA, circleB, circleC];
}

// Function to calculate the medial triangles
function calculateMedialTriangle(points) {
    const [A, B, C] = points;

    return [
        midpoint(B, C),
        midpoint(C, A),
        midpoint(A, B)
    ];
}

// Function to calculate the excentral triangles
function calculateExcentralTriangle(points) {
    const [A, B, C] = points;

    return [
        calculateExcenter([C, A, B]),
        calculateExcenter([A, B, C]),
        calculateExcenter([B, C, A])
    ];
}

// Function to calculate the orthic triangles
function calculateOrthicTriangle(points) {
    const [A, B, C] = points;
    const slopeAB = calculateSlope(A, B);
    const slopeBC = calculateSlope(B, C);
    const slopeCA = calculateSlope(C, A);
    const perpendicularSlopeAB = perpendicularSlope(slopeAB);
    const perpendicularSlopeBC = perpendicularSlope(slopeBC);
    const perpendicularSlopeCA = perpendicularSlope(slopeCA);
    return [
        lineIntersectionGivenSlopesAndPoints(slopeBC, B, perpendicularSlopeBC, A),
        lineIntersectionGivenSlopesAndPoints(slopeCA, C, perpendicularSlopeCA, B),
        lineIntersectionGivenSlopesAndPoints(slopeAB, A, perpendicularSlopeAB, C)
    ];
}

// Function to calculate the outer Napoleon triangle
function calculateNapoleonTriangle(points, outer = true) {
    const [A, B, C] = points;

    // Calculate the outer equilateral triangle on each side
    const crossProductAB_AC = calculateCrossProduct(A, B, C);

    // Determine rotation direction based on cross products
    let rotationRadian = crossProductAB_AC > 0 ? -60 : 60;
    if (!outer){
        rotationRadian = -rotationRadian; 
    }

    // Create equilateral triangles on each side
    const R1 = rotate(B, A, rotationRadian);
    const R2 = rotate(C, B, rotationRadian);
    const R3 = rotate(A, C, rotationRadian);

    // Return the points of the outer Napoleon triangle
    return [
        calculateCentroid([B, C, R2]),
        calculateCentroid([C, A, R3]),
        calculateCentroid([A, B, R1])
    ];
}

// Function to calculate the Gergonne triangle
function calculateGergonneTriangle(points) {
    const [A, B, C] = points;
    const incenter = calculateIncenter(points);
    // Slopes of perpendicular bisectors
    const slopeAB = calculateSlope(A, B);
    const slopeBC = calculateSlope(B, C);
    const slopeCA = calculateSlope(C, A);
    const perpendicularSlopeAB = perpendicularSlope(slopeAB);
    const perpendicularSlopeBC = perpendicularSlope(slopeBC);
    const perpendicularSlopeCA = perpendicularSlope(slopeCA);

    return [
        lineIntersectionGivenSlopesAndPoints(slopeBC, B, perpendicularSlopeBC, incenter),
        lineIntersectionGivenSlopesAndPoints(slopeCA, C, perpendicularSlopeCA, incenter),
        lineIntersectionGivenSlopesAndPoints(slopeAB, A, perpendicularSlopeAB, incenter)
    ];
}

// Function to calculate the extouch triangle
function calculateExtouchTriangle(points) {
    const [A, B, C] = points;
    const excenterA = calculateExcenter([C, A, B]);
    const excenterB = calculateExcenter([A, B, C]);
    const excenterC = calculateExcenter([B, C, A]);

    // Slopes of perpendicular bisectors
    const slopeAB = calculateSlope(A, B);
    const slopeBC = calculateSlope(B, C);
    const slopeCA = calculateSlope(C, A);
    const perpendicularSlopeAB = perpendicularSlope(slopeAB);
    const perpendicularSlopeBC = perpendicularSlope(slopeBC);
    const perpendicularSlopeCA = perpendicularSlope(slopeCA);

    return [
        lineIntersectionGivenSlopesAndPoints(slopeBC, B, perpendicularSlopeBC, excenterA),
        lineIntersectionGivenSlopesAndPoints(slopeCA, C, perpendicularSlopeCA, excenterB),
        lineIntersectionGivenSlopesAndPoints(slopeAB, A, perpendicularSlopeAB, excenterC)
    ];
}

// Function to calculate the Fuhrmann triangle
function calculateFuhrmannTriangle(points) {
    // Function to calculate point bisecting the arc AC length opposite to the points B
    function calculatePointBisectingArc(points) {
        const [A, B, C] = points;
        const circumcircle = calculateCircumcircle(points);
        const circumcenter = circumcircle.center;
        const circumradius = circumcircle.radius;
        const crossProductBA_BC = calculateCrossProduct(B, A, C);
        const perpendicularSlopeCA = perpendicularSlope(calculateSlope(C, A));
        const sqrtDenominator = Math.sqrt(perpendicularSlopeCA**2 + 1);
        // Two candidate points to bisect the arc length P1, P2
        const P1 = {
            x: circumcenter.x + circumradius / sqrtDenominator,
            y: isFinite(perpendicularSlopeCA) ? 
            circumcenter.y + circumradius * perpendicularSlopeCA / sqrtDenominator
            : circumcenter.y + circumradius
        };
        const P2 = {
            x: circumcenter.x - circumradius / sqrtDenominator,
            y: isFinite(perpendicularSlopeCA) ? 
            circumcenter.y - circumradius * perpendicularSlopeCA / sqrtDenominator
            : circumcenter.y - circumradius
        };
        crossProductP1A_P1C = calculateCrossProduct(P1, A, C);
        return (crossProductBA_BC * crossProductP1A_P1C < 0) ? P1 : P2;
    }

    const [A, B, C] = points;
    const midpointAB = midpoint(A, B);
    const midpointBC = midpoint(B, C);
    const midpointCA = midpoint(C, A);
    const PA = calculatePointBisectingArc([C, A, B]);
    const PB = calculatePointBisectingArc([A, B, C]);
    const PC = calculatePointBisectingArc([B, C, A]);
    return [
        {
            x: 2 * midpointBC.x - PA.x,
            y: 2 * midpointBC.y - PA.y
        },
        {
            x: 2 * midpointCA.x - PB.x,
            y: 2 * midpointCA.y - PB.y
        },
        {
            x: 2 * midpointAB.x - PC.x,
            y: 2 * midpointAB.y - PC.y
        },

    ];
}


// Function to calculate the Feuerbach triangle
function calculateFeuerbachTriangle(points) {
    const [A, B, C] = points;
    const excircleA = calculateExcircle([C, A, B]);
    const excircleB = calculateExcircle([A, B, C]);
    const excircleC = calculateExcircle([B, C, A]);
    const ninePointCircle = calculateNinePointCircle(points);

    return [
        calculateTangencyPoint(ninePointCircle, excircleA),
        calculateTangencyPoint(ninePointCircle, excircleB),
        calculateTangencyPoint(ninePointCircle, excircleC)
    ];
}

</script>
</body>
</html>
